
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>ome: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">terraform-provider-ome/ome/datasource_baseline_compliance_report.go (77.6%)</option>
				
				<option value="file1">terraform-provider-ome/ome/datasource_groupdevices.go (75.6%)</option>
				
				<option value="file2">terraform-provider-ome/ome/datasource_template.go (82.1%)</option>
				
				<option value="file3">terraform-provider-ome/ome/datasource_vlannetworks.go (75.0%)</option>
				
				<option value="file4">terraform-provider-ome/ome/defaults.go (87.5%)</option>
				
				<option value="file5">terraform-provider-ome/ome/provider.go (64.4%)</option>
				
				<option value="file6">terraform-provider-ome/ome/resource_configuration_baseline.go (77.5%)</option>
				
				<option value="file7">terraform-provider-ome/ome/resource_configuration_compliance.go (71.6%)</option>
				
				<option value="file8">terraform-provider-ome/ome/resource_deploy.go (80.3%)</option>
				
				<option value="file9">terraform-provider-ome/ome/resource_template.go (79.0%)</option>
				
				<option value="file10">terraform-provider-ome/ome/template_validators.go (79.5%)</option>
				
				<option value="file11">terraform-provider-ome/ome/validators.go (68.4%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package ome

import (
        "context"
        "terraform-provider-ome/clients"
        "terraform-provider-ome/models"

        "github.com/hashicorp/terraform-plugin-framework/datasource"
        "github.com/hashicorp/terraform-plugin-framework/datasource/schema"
        "github.com/hashicorp/terraform-plugin-framework/types"
)

var (
        _ datasource.DataSource              = &amp;configurationReportDataSource{}
        _ datasource.DataSourceWithConfigure = &amp;configurationReportDataSource{}
)

// NewConfigurationReportDataSource is a new datasource for configuration report
func NewConfigurationReportDataSource() datasource.DataSource <span class="cov8" title="1">{
        return &amp;configurationReportDataSource{}
}</span>

type configurationReportDataSource struct {
        p *omeProvider
}

// Configure implements datasource.DataSourceWithConfigure
func (g *configurationReportDataSource) Configure(ctx context.Context, req datasource.ConfigureRequest, resp *datasource.ConfigureResponse) <span class="cov8" title="1">{
        if req.ProviderData == nil </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">g.p = req.ProviderData.(*omeProvider)</span>
}

// Metadata implements datasource.DataSource
func (*configurationReportDataSource) Metadata(ctx context.Context, req datasource.MetadataRequest, resp *datasource.MetadataResponse) <span class="cov8" title="1">{
        resp.TypeName = req.ProviderTypeName + "configuration_report_info"
}</span>

func (*configurationReportDataSource) Schema(ctx context.Context, req datasource.SchemaRequest, resp *datasource.SchemaResponse) <span class="cov8" title="1">{
        resp.Schema = schema.Schema{
                MarkdownDescription: "Data source to list the compliance configuration report of a baseline from OpenManage Enterprise.",
                Attributes: map[string]schema.Attribute{

                        "id": schema.StringAttribute{
                                MarkdownDescription: "ID for baseline compliance data source.",
                                Description:         "ID for baseline compliance data source.",
                                Computed:            true,
                                Optional:            true,
                        },
                        "baseline_name": schema.StringAttribute{
                                MarkdownDescription: "Name of the Baseline.",
                                Description:         "Name of the Baseline.",
                                Required:            true,
                        },
                        "fetch_attributes": schema.BoolAttribute{
                                MarkdownDescription: "Fetch  device compliance attribute report.",
                                Description:         "Fetch  device compliance attribute report.",
                                Computed:            true,
                                Optional:            true,
                        },
                        "compliance_report_device": schema.ListNestedAttribute{
                                MarkdownDescription: "Device compliance report.",
                                Description:         "Device compliance report.",
                                Computed:            true,
                                NestedObject: schema.NestedAttributeObject{
                                        Attributes: map[string]schema.Attribute{
                                                "device_id": schema.Int64Attribute{
                                                        MarkdownDescription: "Device ID",
                                                        Description:         "Device ID",
                                                        Computed:            true,
                                                },
                                                "device_servicetag": schema.StringAttribute{
                                                        MarkdownDescription: "Device servicetag.",
                                                        Description:         "Device servicetag.",
                                                        Computed:            true,
                                                },
                                                "device_name": schema.StringAttribute{
                                                        MarkdownDescription: "Device Name.",
                                                        Description:         "Device Name.",
                                                        Computed:            true,
                                                },
                                                "model": schema.StringAttribute{
                                                        MarkdownDescription: "Device model.",
                                                        Description:         "Device model.",
                                                        Computed:            true,
                                                },
                                                "compliance_status": schema.StringAttribute{
                                                        MarkdownDescription: "Device compliance status.",
                                                        Description:         "Device compliance status.",
                                                        Computed:            true,
                                                },
                                                "device_type": schema.Int64Attribute{
                                                        MarkdownDescription: "Device type",
                                                        Description:         "Device type",
                                                        Computed:            true,
                                                },
                                                "inventory_time": schema.StringAttribute{
                                                        MarkdownDescription: "Inventory Time.",
                                                        Description:         "Inventory Time.",
                                                        Computed:            true,
                                                },
                                                "device_compliance_details": schema.StringAttribute{
                                                        MarkdownDescription: "Device compliance details.",
                                                        Description:         "Device compliance details.",
                                                        Computed:            true,
                                                },
                                        },
                                },
                        },
                },
        }
}</span>

// Read resource information
func (g *configurationReportDataSource) Read(ctx context.Context, req datasource.ReadRequest, resp *datasource.ReadResponse) <span class="cov8" title="1">{
        var config models.ConfigurationReports
        diags := req.Config.Get(ctx, &amp;config)
        resp.Diagnostics.Append(diags...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">omeClient, err := clients.NewClient(*g.p.clientOpt)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        clients.ErrCreateClient,
                        err.Error(),
                )
                return
        }</span>

        <span class="cov8" title="1">_, err = omeClient.CreateSession()
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        clients.ErrCreateSession,
                        err.Error(),
                )
                return
        }</span>
        <span class="cov8" title="1">defer omeClient.RemoveSession()

        var state models.ConfigurationReports

        baseline, err := omeClient.GetBaselineByName(config.BaseLineName.ValueString())
        if err != nil </span><span class="cov8" title="1">{
                resp.Diagnostics.AddError(
                        clients.ErrGnrConfigurationReport, err.Error(),
                )
                return
        }</span>
        <span class="cov8" title="1">if baseline.ConfigComplianceSummary.ComplianceStatus != "NotInventored" </span><span class="cov8" title="1">{

                baselineID := baseline.ID

                complianceReports, err := omeClient.GetBaselineDevComplianceReportsByID(baselineID)
                if err != nil </span><span class="cov0" title="0">{
                        resp.Diagnostics.AddError(
                                clients.ErrGnrConfigurationReport, err.Error(),
                        )
                        return
                }</span>
                <span class="cov8" title="1">state.BaseLineName = config.BaseLineName
                state.ID = config.BaseLineName

                for _, cr := range complianceReports </span><span class="cov8" title="1">{
                        compStatus := "Compliant"
                        if cr.ComplianceStatus != 1 </span><span class="cov0" title="0">{
                                compStatus = "Non Compliant"
                        }</span>
                        <span class="cov8" title="1">crd := models.ComplianceReportDevice{
                                DeviceID:         types.Int64Value(cr.ID),
                                DeviceServiceTag: types.StringValue(cr.ServiceTag),
                                DeviceName:       types.StringValue(cr.DeviceName),
                                Model:            types.StringValue(cr.Model),
                                ComplianceStatus: types.StringValue(compStatus),
                                DeviceType:       types.Int64Value(cr.DeviceType),
                                InventoryTime:    types.StringValue(cr.InventoryTime),
                        }
                        if config.FetchAttributes.ValueBool() </span><span class="cov8" title="1">{
                                attrResp, err := omeClient.GetBaselineDevAttrComplianceReportsByID(baselineID, cr.ID)
                                if err != nil </span><span class="cov0" title="0">{
                                        resp.Diagnostics.AddError(
                                                clients.ErrGnrConfigurationReport, err.Error(),
                                        )
                                        return
                                }</span>
                                <span class="cov8" title="1">crd.DeviceComplianceDetails = types.StringValue(attrResp)</span>
                        }
                        <span class="cov8" title="1">state.ComplianceReportDevice = append(state.ComplianceReportDevice, crd)</span>
                }
        }
        <span class="cov8" title="1">diags = resp.State.Set(ctx, &amp;state)
        resp.Diagnostics.Append(diags...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package ome

import (
        "context"
        "terraform-provider-ome/clients"
        "terraform-provider-ome/models"

        "github.com/hashicorp/terraform-plugin-framework/attr"
        "github.com/hashicorp/terraform-plugin-framework/datasource"
        "github.com/hashicorp/terraform-plugin-framework/datasource/schema"
        "github.com/hashicorp/terraform-plugin-framework/types"
)

var (
        _ datasource.DataSource              = &amp;groupDevicesDatasource{}
        _ datasource.DataSourceWithConfigure = &amp;groupDevicesDatasource{}
)

// NewGroupDevicesDatasource is new datasource for group devices
func NewGroupDevicesDatasource() datasource.DataSource <span class="cov8" title="1">{
        return &amp;groupDevicesDatasource{}
}</span>

type groupDevicesDatasource struct {
        p *omeProvider
}

// Configure implements datasource.DataSourceWithConfigure
func (g *groupDevicesDatasource) Configure(ctx context.Context, req datasource.ConfigureRequest, resp *datasource.ConfigureResponse) <span class="cov8" title="1">{
        if req.ProviderData == nil </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">g.p = req.ProviderData.(*omeProvider)</span>
}

// Metadata implements datasource.DataSource
func (*groupDevicesDatasource) Metadata(ctx context.Context, req datasource.MetadataRequest, resp *datasource.MetadataResponse) <span class="cov8" title="1">{
        resp.TypeName = req.ProviderTypeName + "groupdevices_info"
}</span>

// Schema implements datasource.DataSource
func (*groupDevicesDatasource) Schema(ctx context.Context, req datasource.SchemaRequest, resp *datasource.SchemaResponse) <span class="cov8" title="1">{
        resp.Schema = schema.Schema{
                MarkdownDescription: "Data source to list the devices in the group from OpenManage Enterprise.",
                Attributes: map[string]schema.Attribute{

                        "id": schema.StringAttribute{
                                MarkdownDescription: "ID for group devices data source.",
                                Description:         "ID for group devices data source.",
                                Computed:            true,
                                Optional:            true,
                        },

                        "device_ids": schema.ListAttribute{
                                MarkdownDescription: "List of the device id(s) associated with a group",
                                Description:         "List of the device id(s) associated with a group",
                                ElementType:         types.Int64Type,
                                Computed:            true,
                        },

                        "device_servicetags": schema.ListAttribute{
                                MarkdownDescription: "List of the device servicetags associated with a group",
                                Description:         "List of the device servicetags associated with a group",
                                ElementType:         types.StringType,
                                Computed:            true,
                        },
                        "device_group_names": schema.SetAttribute{
                                MarkdownDescription: "List of the device group names.",
                                Description:         "List of the device group names.",
                                ElementType:         types.StringType,
                                Required:            true,
                        },
                },
        }
}</span>

// Read implements datasource.DataSource
func (g *groupDevicesDatasource) Read(ctx context.Context, req datasource.ReadRequest, resp *datasource.ReadResponse) <span class="cov8" title="1">{
        var groupDevices models.GroupDevicesData
        diags := req.Config.Get(ctx, &amp;groupDevices)
        resp.Diagnostics.Append(diags...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">groupNames := []string{}
        diags = groupDevices.DeviceGroupNames.ElementsAs(ctx, &amp;groupNames, true)
        if diags.HasError() </span><span class="cov0" title="0">{
                resp.Diagnostics.Append(diags...)
                return
        }</span>

        <span class="cov8" title="1">omeClient, err := clients.NewClient(*g.p.clientOpt)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Unable to create client",
                        err.Error(),
                )
                return
        }</span>

        <span class="cov8" title="1">_, err = omeClient.CreateSession()
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Unable to create OME session: ",
                        err.Error(),
                )
                return
        }</span>
        <span class="cov8" title="1">defer omeClient.RemoveSession()

        devices, err := omeClient.GetDevicesByGroups(groupNames)
        if err != nil &amp;&amp; len(devices) != 0 </span><span class="cov0" title="0">{
                resp.Diagnostics.AddWarning(
                        "Unable to fetch devices during pagination: ",
                        err.Error(),
                )
        }</span> else<span class="cov8" title="1"> if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Unable to fetch devices for groups: ",
                        err.Error(),
                )
                return
        }</span>
        <span class="cov8" title="1">devIDs := []attr.Value{}
        devSvcTags := []attr.Value{}
        devices = omeClient.GetUniqueDevices(devices)

        for _, device := range devices </span><span class="cov8" title="1">{
                devIDs = append(devIDs, types.Int64Value(device.ID))
                devSvcTags = append(devSvcTags, types.StringValue(device.DeviceServiceTag))
        }</span>

        <span class="cov8" title="1">devIDsTfsdk, _ := types.ListValue(
                types.Int64Type,
                devIDs,
        )

        groupDevices.DeviceIDs = devIDsTfsdk

        devSTsTfsdk, _ := types.ListValue(
                types.StringType,
                devSvcTags,
        )

        groupDevices.DeviceServicetags = devSTsTfsdk

        diags = resp.State.Set(ctx, &amp;groupDevices)
        resp.Diagnostics.Append(diags...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package ome

import (
        "context"
        "fmt"
        "terraform-provider-ome/clients"
        "terraform-provider-ome/models"

        "github.com/hashicorp/terraform-plugin-framework/attr"
        "github.com/hashicorp/terraform-plugin-framework/datasource"
        "github.com/hashicorp/terraform-plugin-framework/datasource/schema"
        "github.com/hashicorp/terraform-plugin-framework/types"
        "github.com/hashicorp/terraform-plugin-framework/types/basetypes"
)

var (
        _ datasource.DataSource              = &amp;templateDataSource{}
        _ datasource.DataSourceWithConfigure = &amp;templateDataSource{}
)

// NewTemplateDataSource is a new datasource for template
func NewTemplateDataSource() datasource.DataSource <span class="cov8" title="1">{
        return &amp;templateDataSource{}
}</span>

type templateDataSource struct {
        p *omeProvider
}

// Configure implements datasource.DataSourceWithConfigure
func (t *templateDataSource) Configure(ctx context.Context, req datasource.ConfigureRequest, resp *datasource.ConfigureResponse) <span class="cov8" title="1">{
        if req.ProviderData == nil </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">t.p = req.ProviderData.(*omeProvider)</span>
}

// Metadata implements datasource.DataSource
func (*templateDataSource) Metadata(ctx context.Context, req datasource.MetadataRequest, resp *datasource.MetadataResponse) <span class="cov8" title="1">{
        resp.TypeName = req.ProviderTypeName + "template_info"
}</span>

func (t templateDataSource) Schema(_ context.Context, _ datasource.SchemaRequest, resp *datasource.SchemaResponse) <span class="cov8" title="1">{
        resp.Schema = schema.Schema{
                MarkdownDescription: "Data Source to list the Template details from OpenManage Enterprise",
                Attributes: map[string]schema.Attribute{
                        "id": schema.StringAttribute{
                                MarkdownDescription: "ID of the template data source.",
                                Description:         "ID of the template data source.",
                                Computed:            true,
                                Optional:            true,
                        },
                        "name": schema.StringAttribute{
                                MarkdownDescription: "Name of the template.",
                                Description:         "Name of the template.",
                                Required:            true,
                        },
                        "view_type_id": schema.Int64Attribute{
                                MarkdownDescription: "OME template view type id.",
                                Description:         "OME template view type id.",
                                Computed:            true,
                        },
                        "device_type_id": schema.Int64Attribute{
                                MarkdownDescription: "Template type ID, indicating the type of device for which configuration is supported, current supported device is server",
                                Description:         "Template type ID, indicating the type of device for which configuration is supported, current supported device is server",
                                Computed:            true,
                        },
                        "refdevice_id": schema.Int64Attribute{
                                MarkdownDescription: "Target device id from which the template is created.",
                                Description:         "Target device id from which the template is created.",
                                Optional:            true,
                                Computed:            true,
                        },
                        "content": schema.StringAttribute{
                                MarkdownDescription: "The XML content of template from which the template will be created",
                                Description:         "The XML content of template from which the template will be created",
                                Optional:            true,
                        },
                        "description": schema.StringAttribute{
                                MarkdownDescription: "Description for the template.",
                                Description:         "Description for the template.",
                                Optional:            true,
                                Computed:            true,
                        },
                        "attributes": schema.ListAttribute{
                                MarkdownDescription: "List of attributes associated with template.",
                                Description:         "List of attributes associated with template.",
                                Optional:            true,
                                Computed:            true,
                                ElementType: types.ObjectType{
                                        AttrTypes: map[string]attr.Type{
                                                "attribute_id": types.Int64Type,
                                                "display_name": types.StringType,
                                                "value":        types.StringType,
                                                "is_ignored":   types.BoolType,
                                        },
                                },
                        },
                        "identity_pool_id": schema.Int64Attribute{
                                MarkdownDescription: "ID of the Identity Pool attached with template.",
                                Description:         "ID of the Identity Pool attached with template.",
                                Computed:            true,
                        },
                        "vlan": schema.ObjectAttribute{
                                MarkdownDescription: "VLAN details to be attached with template.",
                                Description:         "VLAN details to be attached with template.",
                                Computed:            true,
                                Optional:            true,
                                AttributeTypes: map[string]attr.Type{
                                        "propogate_vlan":     types.BoolType,
                                        "bonding_technology": types.StringType,
                                        "vlan_attributes": types.ListType{
                                                ElemType: types.ObjectType{
                                                        AttrTypes: map[string]attr.Type{
                                                                "untagged_network": types.Int64Type,
                                                                "tagged_networks": types.ListType{
                                                                        ElemType: types.Int64Type,
                                                                },
                                                                "is_nic_bonded":  types.BoolType,
                                                                "port":           types.Int64Type,
                                                                "nic_identifier": types.StringType,
                                                        },
                                                },
                                        },
                                },
                        },
                },
        }
}</span>

// Read resource information
func (t templateDataSource) Read(ctx context.Context, req datasource.ReadRequest, resp *datasource.ReadResponse) <span class="cov8" title="1">{
        var template models.TemplateDataSource
        diags := req.Config.Get(ctx, &amp;template)
        resp.Diagnostics.Append(diags...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">templateName := template.Name.ValueString()
        omeClient, err := clients.NewClient(*t.p.clientOpt)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Unable to create client",
                        err.Error(),
                )
                return
        }</span>

        <span class="cov8" title="1">_, err = omeClient.CreateSession()
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Unable to create OME session: ",
                        err.Error(),
                )
                return
        }</span>
        <span class="cov8" title="1">defer omeClient.RemoveSession()

        stateAttributes := []models.Attribute{}

        omeTemplateData, err := omeClient.GetTemplateByName(templateName)
        if err == nil &amp;&amp; omeTemplateData.Name == "" </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "error reading the template", err.Error(),
                )
                return
        }</span>

        <span class="cov8" title="1">omeAttributes, err := omeClient.GetTemplateAttributes(omeTemplateData.ID, stateAttributes, true)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Unable to refresh template attributes:",
                        err.Error(),
                )
                return
        }</span>
        <span class="cov8" title="1">stateVlan := models.Vlan{}
        diags = template.Vlan.As(ctx, &amp;stateVlan, basetypes.ObjectAsOptions{UnhandledNullAsEmpty: true})
        if diags.HasError() </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Unable to fetch Vlan from state ",
                        "Hence, Cannot refresh the template resource",
                )
                return
        }</span>

        <span class="cov8" title="1">omeVlan, err := omeClient.GetSchemaVlanData(omeTemplateData.ID)
        if err != nil </span><span class="cov0" title="0">{
                if err != nil </span><span class="cov0" title="0">{
                        resp.Diagnostics.AddError(
                                "Unable to refresh vlan attributes:",
                                err.Error(),
                        )
                        return
                }</span>
        }

        <span class="cov8" title="1">omeVlan.PropagateVLAN = stateVlan.PropogateVlan.ValueBool()
        updateDataSourceState(&amp;template, &amp;omeTemplateData, omeAttributes, omeVlan)

        diags = resp.State.Set(ctx, &amp;template)
        resp.Diagnostics.Append(diags...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>
}

func updateDataSourceState(template *models.TemplateDataSource, omeTemplateData *models.OMETemplate, omeTemplateAttributes []models.OmeAttribute, omeVlan models.OMEVlan) <span class="cov8" title="1">{

        template.ID = types.StringValue(fmt.Sprintf("%d", omeTemplateData.ID))
        template.Name = types.StringValue(omeTemplateData.Name)
        template.Description = types.StringValue(omeTemplateData.Description)
        template.ViewTypeID = types.Int64Value(omeTemplateData.ViewTypeID)
        template.DeviceTypeID = types.Int64Value(omeTemplateData.TypeID)
        template.RefdeviceID = types.Int64Value(omeTemplateData.SourceDeviceID)
        template.IdentityPoolID = types.Int64Value(omeTemplateData.IdentityPoolID)
        template.Content = types.StringValue(omeTemplateData.Content)
        attributeObjects := []attr.Value{}

        for _, attribute := range omeTemplateAttributes </span><span class="cov8" title="1">{
                attributeDetails := map[string]attr.Value{}
                attributeDetails["attribute_id"] = types.Int64Value(attribute.AttributeID)
                attributeDetails["display_name"] = types.StringValue(attribute.DisplayName)
                attributeDetails["value"] = types.StringValue(attribute.Value)
                attributeDetails["is_ignored"] = types.BoolValue(attribute.IsIgnored)
                attributeObject, _ := types.ObjectValue(
                        map[string]attr.Type{
                                "attribute_id": types.Int64Type,
                                "display_name": types.StringType,
                                "value":        types.StringType,
                                "is_ignored":   types.BoolType,
                        }, attributeDetails,
                )
                attributeObjects = append(attributeObjects, attributeObject)
        }</span>
        <span class="cov8" title="1">attributesTfsdk, _ := types.ListValue(
                types.ObjectType{
                        AttrTypes: map[string]attr.Type{
                                "attribute_id": types.Int64Type,
                                "display_name": types.StringType,
                                "value":        types.StringType,
                                "is_ignored":   types.BoolType,
                        },
                },
                attributeObjects,
        )

        template.Attributes = attributesTfsdk

        var vlanTfsdk types.Object
        vlanAttrsObjects := []attr.Value{}

        for _, omeVlanAttr := range omeVlan.OMEVlanAttributes </span><span class="cov8" title="1">{

                vlanAttrMap := map[string]attr.Value{}
                vlanAttrMap["untagged_network"] = types.Int64Value(omeVlanAttr.Untagged)
                taggedNetworks := []attr.Value{}
                for _, tn := range omeVlanAttr.Tagged </span><span class="cov8" title="1">{
                        taggedNetworks = append(taggedNetworks, types.Int64Value(tn))
                }</span>

                <span class="cov8" title="1">vlanAttrMap["tagged_networks"], _ = types.ListValue(
                        types.Int64Type,
                        taggedNetworks,
                )
                vlanAttrMap["is_nic_bonded"] = types.BoolValue(omeVlanAttr.IsNICBonded)
                vlanAttrMap["port"] = types.Int64Value(omeVlanAttr.Port)
                vlanAttrMap["nic_identifier"] = types.StringValue(omeVlanAttr.NicIdentifier)
                vlanAttrObject, _ := types.ObjectValue(
                        map[string]attr.Type{
                                "untagged_network": types.Int64Type,
                                "tagged_networks": types.ListType{
                                        ElemType: types.Int64Type,
                                },
                                "is_nic_bonded":  types.BoolType,
                                "port":           types.Int64Type,
                                "nic_identifier": types.StringType,
                        }, vlanAttrMap,
                )
                vlanAttrsObjects = append(vlanAttrsObjects, vlanAttrObject)</span>
        }

        <span class="cov8" title="1">vlanAttrList, _ := types.ListValue(
                types.ObjectType{
                        AttrTypes: map[string]attr.Type{
                                "untagged_network": types.Int64Type,
                                "tagged_networks": types.ListType{
                                        ElemType: types.Int64Type,
                                },
                                "is_nic_bonded":  types.BoolType,
                                "port":           types.Int64Type,
                                "nic_identifier": types.StringType,
                        },
                },
                vlanAttrsObjects,
        )
        vlanTfsdk, _ = types.ObjectValue(
                map[string]attr.Type{
                        "propogate_vlan":     types.BoolType,
                        "bonding_technology": types.StringType,
                        "vlan_attributes": types.ListType{
                                ElemType: types.ObjectType{
                                        AttrTypes: map[string]attr.Type{
                                                "untagged_network": types.Int64Type,
                                                "tagged_networks": types.ListType{
                                                        ElemType: types.Int64Type,
                                                },
                                                "is_nic_bonded":  types.BoolType,
                                                "port":           types.Int64Type,
                                                "nic_identifier": types.StringType,
                                        },
                                },
                        },
                },
                map[string]attr.Value{
                        "propogate_vlan":     types.BoolValue(omeVlan.PropagateVLAN),
                        "bonding_technology": types.StringValue(omeVlan.BondingTechnology),
                        "vlan_attributes":    vlanAttrList,
                },
        )

        template.Vlan = vlanTfsdk</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package ome

import (
        "context"
        "terraform-provider-ome/clients"
        "terraform-provider-ome/models"

        "github.com/hashicorp/terraform-plugin-framework/datasource"
        "github.com/hashicorp/terraform-plugin-framework/datasource/schema"
        "github.com/hashicorp/terraform-plugin-framework/types"
)

var (
        _ datasource.DataSource              = &amp;vlanNetworksDataSource{}
        _ datasource.DataSourceWithConfigure = &amp;vlanNetworksDataSource{}
)

// NewVlanNetworkDataSource is a new datasource for VlanNetwork
func NewVlanNetworkDataSource() datasource.DataSource <span class="cov8" title="1">{
        return &amp;vlanNetworksDataSource{}
}</span>

type vlanNetworksDataSource struct {
        p *omeProvider
}

// Configure implements datasource.DataSourceWithConfigure
func (g *vlanNetworksDataSource) Configure(ctx context.Context, req datasource.ConfigureRequest, resp *datasource.ConfigureResponse) <span class="cov8" title="1">{
        if req.ProviderData == nil </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">g.p = req.ProviderData.(*omeProvider)</span>
}

// Metadata implements datasource.DataSource
func (*vlanNetworksDataSource) Metadata(ctx context.Context, req datasource.MetadataRequest, resp *datasource.MetadataResponse) <span class="cov8" title="1">{
        resp.TypeName = req.ProviderTypeName + "vlannetworks_info"
}</span>

func (g vlanNetworksDataSource) Schema(_ context.Context, _ datasource.SchemaRequest, resp *datasource.SchemaResponse) <span class="cov8" title="1">{
        resp.Schema = schema.Schema{
                MarkdownDescription: "Data source to list the vlan networks from OpenManage Enterprise.",
                Attributes: map[string]schema.Attribute{
                        "id": schema.StringAttribute{
                                MarkdownDescription: "ID for vlan networks data source.",
                                Description:         "ID for vlan networks data source.",
                                Computed:            true,
                                // Optional:            true,
                        },
                        "vlan_networks": schema.ListNestedAttribute{
                                MarkdownDescription: "List of vlan networks",
                                Description:         "List of vlan networks",
                                Computed:            true,
                                NestedObject: schema.NestedAttributeObject{
                                        Attributes: map[string]schema.Attribute{
                                                "vlan_id": schema.Int64Attribute{
                                                        MarkdownDescription: "Unique ID for the vlan network.",
                                                        Description:         "Unique ID for the vlan network.",
                                                        Computed:            true,
                                                },
                                                "name": schema.StringAttribute{
                                                        MarkdownDescription: "Name of the vlan network.",
                                                        Description:         "Name of the vlan network.",
                                                        Computed:            true,
                                                },
                                                "description": schema.StringAttribute{
                                                        MarkdownDescription: "Description of the vlan network.",
                                                        Description:         "Description of the vlan network.",
                                                        Computed:            true,
                                                },
                                                "vlan_maximum": schema.Int64Attribute{
                                                        MarkdownDescription: "Vlan maximum.",
                                                        Description:         "Vlan maximum.",
                                                        Computed:            true,
                                                },
                                                "vlan_minimum": schema.Int64Attribute{
                                                        MarkdownDescription: "Vlan minimum.",
                                                        Description:         "Vlan minimum.",
                                                        Computed:            true,
                                                },
                                                "type": schema.Int64Attribute{
                                                        MarkdownDescription: "Type of vlan.",
                                                        Description:         "Type of vlan.",
                                                        Computed:            true,
                                                },
                                                "internal_ref_nwuu_id": schema.StringAttribute{
                                                        MarkdownDescription: "Reference ID for a vlan.",
                                                        Description:         "Reference ID for a vlan.",
                                                        Computed:            true,
                                                },
                                        },
                                },
                        },
                },
        }
}</span>

// Read resource information
func (g vlanNetworksDataSource) Read(ctx context.Context, req datasource.ReadRequest, resp *datasource.ReadResponse) <span class="cov8" title="1">{
        var state models.VLanNetworksTypeTfsdk
        state.ID = types.StringValue("0")

        omeClient, err := clients.NewClient(*g.p.clientOpt)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Unable to create client",
                        err.Error(),
                )
                return
        }</span>

        <span class="cov8" title="1">_, err = omeClient.CreateSession()
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Unable to create OME session: ",
                        err.Error(),
                )
                return
        }</span>
        <span class="cov8" title="1">defer omeClient.RemoveSession()

        vlanNetworksOme, err := omeClient.GetAllVlanNetworks()
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddWarning(
                        "unable to get the vlan netowrk details",
                        err.Error(),
                )
                return
        }</span>

        <span class="cov8" title="1">for _, vn := range vlanNetworksOme </span><span class="cov8" title="1">{
                vlanNetTsfdk := models.VLanNetworksTfsdk{
                        VlanID:            types.Int64Value(vn.ID),
                        Name:              types.StringValue(vn.Name),
                        Description:       types.StringValue(vn.Description),
                        VLANMaximum:       types.Int64Value(vn.VLANMaximum),
                        VLANMinimum:       types.Int64Value(vn.VLANMinimum),
                        Type:              types.Int64Value(vn.Type),
                        InternalRefNWUUID: types.StringValue(vn.InternalRefNWUUID),
                }
                state.VlanNetworks = append(state.VlanNetworks, vlanNetTsfdk)
        }</span>

        <span class="cov8" title="1">diags := resp.State.Set(ctx, &amp;state)
        resp.Diagnostics.Append(diags...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package ome

import (
        "context"
        "fmt"

        "github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
        "github.com/hashicorp/terraform-plugin-framework/types"
)

// Int64DefaultValue set default value for int64 type
func Int64DefaultValue(v types.Int64) planmodifier.Int64 <span class="cov8" title="1">{
        return &amp;int64DefaultValuePlanModifier{v}
}</span>

type int64DefaultValuePlanModifier struct {
        DefaultValue types.Int64
}

var _ planmodifier.Int64 = (*int64DefaultValuePlanModifier)(nil)

func (apm *int64DefaultValuePlanModifier) Description(ctx context.Context) string <span class="cov8" title="1">{
        return fmt.Sprintf("If value is not configured, defaults to %s", apm.DefaultValue)
}</span>

func (apm *int64DefaultValuePlanModifier) MarkdownDescription(ctx context.Context) string <span class="cov0" title="0">{
        return fmt.Sprintf("If value is not configured, defaults to %s", apm.DefaultValue)
}</span>

func (apm *int64DefaultValuePlanModifier) PlanModifyInt64(ctx context.Context, req planmodifier.Int64Request, res *planmodifier.Int64Response) <span class="cov8" title="1">{
        // If the attribute configuration is not null, we are done here
        if !req.ConfigValue.IsNull() </span><span class="cov8" title="1">{
                return
        }</span>

        // If the attribute plan is "known" and "not null", then a previous plan modifier in the sequence
        // has already been applied, and we don't want to interfere.
        <span class="cov8" title="1">if !req.PlanValue.IsUnknown() &amp;&amp; !req.PlanValue.IsNull() </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">res.PlanValue = apm.DefaultValue</span>
}

// StringDefaultValue set default value for string type
func StringDefaultValue(v types.String) planmodifier.String <span class="cov8" title="1">{
        return &amp;stringDefaultValuePlanModifier{v}
}</span>

type stringDefaultValuePlanModifier struct {
        DefaultValue types.String
}

// Description implements planmodifier.String
func (apm *stringDefaultValuePlanModifier) Description(context.Context) string <span class="cov8" title="1">{
        return fmt.Sprintf("If value is not configured, defaults to %s", apm.DefaultValue)
}</span>

// MarkdownDescription implements planmodifier.String
func (apm *stringDefaultValuePlanModifier) MarkdownDescription(context.Context) string <span class="cov0" title="0">{
        return fmt.Sprintf("If value is not configured, defaults to %s", apm.DefaultValue)
}</span>

// PlanModifyString implements planmodifier.String
func (apm *stringDefaultValuePlanModifier) PlanModifyString(ctx context.Context, req planmodifier.StringRequest, res *planmodifier.StringResponse) <span class="cov8" title="1">{
        // If the attribute configuration is not null, we are done here
        if !req.ConfigValue.IsNull() </span><span class="cov8" title="1">{
                return
        }</span>

        // If the attribute plan is "known" and "not null", then a previous plan modifier in the sequence
        // has already been applied, and we don't want to interfere.
        <span class="cov8" title="1">if !req.PlanValue.IsUnknown() &amp;&amp; !req.PlanValue.IsNull() </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">res.PlanValue = apm.DefaultValue</span>
}

// BoolDefaultValue sets default value for bool type
func BoolDefaultValue(v types.Bool) planmodifier.Bool <span class="cov8" title="1">{
        return &amp;BoolDefaultValuePlanModifier{v}
}</span>

// BoolDefaultValuePlanModifier for bool type
type BoolDefaultValuePlanModifier struct {
        DefaultValue types.Bool
}

// Description implements planmodifier.Bool
func (apm *BoolDefaultValuePlanModifier) Description(context.Context) string <span class="cov8" title="1">{
        return fmt.Sprintf("If value is not configured, defaults to %s", apm.DefaultValue)
}</span>

// MarkdownDescription implements planmodifier.Bool
func (apm *BoolDefaultValuePlanModifier) MarkdownDescription(context.Context) string <span class="cov0" title="0">{
        return fmt.Sprintf("If value is not configured, defaults to %s", apm.DefaultValue)
}</span>

// PlanModifyBool implements planmodifier.Bool
func (apm *BoolDefaultValuePlanModifier) PlanModifyBool(ctx context.Context, req planmodifier.BoolRequest, res *planmodifier.BoolResponse) <span class="cov8" title="1">{
        // If the attribute configuration is not null, we are done here
        if !req.ConfigValue.IsNull() </span><span class="cov8" title="1">{
                return
        }</span>

        // If the attribute plan is "known" and "not null", then a previous plan modifier in the sequence
        // has already been applied, and we don't want to interfere.
        <span class="cov8" title="1">if !req.PlanValue.IsUnknown() &amp;&amp; !req.PlanValue.IsNull() </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">res.PlanValue = apm.DefaultValue</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package ome

import (
        "context"
        "terraform-provider-ome/clients"
        "time"

        "github.com/hashicorp/terraform-plugin-framework/datasource"
        "github.com/hashicorp/terraform-plugin-framework/provider"
        "github.com/hashicorp/terraform-plugin-framework/provider/schema"
        "github.com/hashicorp/terraform-plugin-framework/resource"
        "github.com/hashicorp/terraform-plugin-framework/types"
        "github.com/hashicorp/terraform-plugin-log/tflog"
)

const (
        defaultPort    int64         = 443
        defaultTimeout time.Duration = time.Second * 30
)

var (
        _ provider.Provider = &amp;omeProvider{}
)

// New - returns new provider struct definition.
func New() provider.Provider <span class="cov8" title="1">{
        return &amp;omeProvider{}
}</span>

type omeProvider struct {
        // client options can contain the upstream provider SDK or HTTP client used to
        // communicate with the upstream service. Resource and DataSource
        // implementations can then make calls using this client.
        //
        clientOpt *clients.ClientOptions

        // configured is set to true at the end of the Configure method.
        // This can be used in Resource and DataSource implementations to verify
        // that the provider was previously configured.
        configured bool
}

// providerData can be used to store data from the Terraform configuration.
type providerData struct {
        Username types.String `tfsdk:"username"`
        Host     types.String `tfsdk:"host"`
        Password types.String `tfsdk:"password"`
        Port     types.Int64  `tfsdk:"port"`
        SkipSSL  types.Bool   `tfsdk:"skipssl"`
        Timeout  types.Int64  `tfsdk:"timeout"`
}

// Metadata - provider metadata AKA name.
func (p *omeProvider) Metadata(_ context.Context, _ provider.MetadataRequest, resp *provider.MetadataResponse) <span class="cov8" title="1">{
        resp.TypeName = "ome_"
}</span>

// Configure - provider pre-initiate calle function.
func (p *omeProvider) Configure(ctx context.Context, req provider.ConfigureRequest, resp *provider.ConfigureResponse) <span class="cov8" title="1">{
        // If the upstream provider SDK or HTTP client requires configuration, such
        // as authentication or logging, this is a great opportunity to do so.
        tflog.Trace(ctx, "Started configuring the provider")
        data := providerData{}
        diags := req.Config.Get(ctx, &amp;data)
        resp.Diagnostics.Append(diags...)

        if data.Username.IsUnknown() </span><span class="cov0" title="0">{
                // Cannot connect to client with an unknown value
                resp.Diagnostics.AddWarning(
                        "Unable to create client",
                        "Cannot use unknown value as username",
                )
                return
        }</span>

        <span class="cov8" title="1">if data.Username.ValueString() == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Unable to find username",
                        "Username cannot be an empty string",
                )
                return
        }</span>

        <span class="cov8" title="1">if data.Password.IsUnknown() </span><span class="cov0" title="0">{
                // Cannot connect to client with an unknown value
                resp.Diagnostics.AddWarning(
                        "Unable to create client",
                        "Cannot use unknown value as password",
                )
                return
        }</span>

        <span class="cov8" title="1">if data.Password.ValueString() == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Unable to find ome password",
                        "password cannot be an empty string",
                )
                return
        }</span>

        <span class="cov8" title="1">if data.Host.IsUnknown() </span><span class="cov0" title="0">{
                // Cannot connect to client with an unknown value
                resp.Diagnostics.AddWarning(
                        "Unable to create client",
                        "Cannot use unknown value as host",
                )
                return
        }</span>

        <span class="cov8" title="1">if data.Host.ValueString() == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Unable to find ome host.",
                        "host cannot be an empty string",
                )
                return
        }</span>

        //Default port to 443
        <span class="cov8" title="1">port := defaultPort
        if data.Port.ValueInt64() != 0 </span><span class="cov0" title="0">{
                port = data.Port.ValueInt64()
        }</span>
        //Default timeout to 30 sec
        <span class="cov8" title="1">timeout := defaultTimeout
        if data.Timeout.ValueInt64() != 0 </span><span class="cov0" title="0">{
                timeout = time.Second * time.Duration(data.Timeout.ValueInt64())
        }</span>

        <span class="cov8" title="1">if data.SkipSSL.IsUnknown() </span><span class="cov0" title="0">{
                // Cannot connect to client with an unknown value
                resp.Diagnostics.AddWarning(
                        "Unable to create client",
                        "Cannot use unknown value as SkipSSL",
                )
                return
        }</span>

        <span class="cov8" title="1">url := clients.GetURL(data.Host.ValueString(), port)

        tflog.Info(ctx, "Collected all data creating client options")

        clientOptions := clients.ClientOptions{
                Username:       data.Username.ValueString(),
                Password:       data.Password.ValueString(),
                URL:            url,
                SkipSSL:        data.SkipSSL.ValueBool(),
                Timeout:        timeout,
                Retry:          clients.Retries,
                PreRequestHook: clients.ClientPreReqHook,
        }
        p.clientOpt = &amp;clientOptions

        p.configured = true
        resp.DataSourceData = p
        resp.ResourceData = p

        tflog.Trace(ctx, p.clientOpt.Username)
        tflog.Trace(ctx, "Finished configuring the provider")</span>
}

func (p *omeProvider) Resources(ctx context.Context) []func() resource.Resource <span class="cov8" title="1">{
        return []func() resource.Resource{
                NewTemplateResource,
                NewDeploymentResource,
                NewConfigurationBaselineResource,
                NewConfigurationComplianceResource,
        }
}</span>

func (p *omeProvider) DataSources(ctx context.Context) []func() datasource.DataSource <span class="cov8" title="1">{
        return []func() datasource.DataSource{
                NewTemplateDataSource,
                NewGroupDevicesDatasource,
                NewVlanNetworkDataSource,
                NewConfigurationReportDataSource,
        }
}</span>

func (p *omeProvider) Schema(ctx context.Context, _ provider.SchemaRequest, resp *provider.SchemaResponse) <span class="cov8" title="1">{
        resp.Schema = schema.Schema{
                MarkdownDescription: "The Terraform Provider for OpenManage Enterprise (OME) is a plugin for Terraform that allows the resource management of PowerEdge servers using OME",
                Attributes: map[string]schema.Attribute{
                        "host": schema.StringAttribute{
                                MarkdownDescription: "OpenManage Enterprise IP address or hostname.",
                                Description:         "OpenManage Enterprise IP address or hostname.",
                                Required:            true,
                        },
                        "username": schema.StringAttribute{
                                MarkdownDescription: "OpenManage Enterprise username.",
                                Description:         "OpenManage Enterprise username.",
                                Required:            true,
                        },
                        "password": schema.StringAttribute{
                                MarkdownDescription: "OpenManage Enterprise password.",
                                Description:         "OpenManage Enterprise password.",
                                Required:            true,
                                Sensitive:           true,
                        },
                        "port": schema.Int64Attribute{
                                MarkdownDescription: "OpenManage Enterprise HTTPS port.",
                                Description:         "OpenManage Enterprise HTTPS port.",
                                Optional:            true,
                        },
                        "skipssl": schema.BoolAttribute{
                                MarkdownDescription: "Skips SSL certificate validation on OpenManage Enterprise",
                                Description:         "Skips SSL certificate validation on OpenManage Enterprise",
                                Optional:            true,
                        },
                        "timeout": schema.Int64Attribute{
                                MarkdownDescription: "HTTPS timeout for OpenManage Enterprise client",
                                Description:         "HTTPS timeout for OpenManage Enterprise client",
                                Optional:            true,
                        },
                },
        }
}</span>

// New method is used to create a new provider via a RPC call or from main
/* func New(version string) func() tfsdk.Provider {
        return func() tfsdk.Provider {
                return &amp;provider{
                        version: version,
                }
        }
} */

/* // convertProviderType is a helper function for NewResource and NewDataSource
// implementations to associate the concrete provider type. Alternatively,
// this helper can be skipped and the provider type can be directly type
// asserted (e.g. provider: in.(*provider)), however using this can prevent
// potential panics.
//
//lint:ignore U1000 used by the internal provider, to be checked
func convertProviderType(in tfsdk.Provider) (provider, diag.Diagnostics) {
        var diags diag.Diagnostics

        p, ok := in.(*provider)

        if !ok {
                diags.AddError(
                        "Unexpected Provider Instance Type",
                        fmt.Sprintf("While creating the data source or resource, an unexpected provider type (%T) was received. This is always a bug in the provider code and should be reported to the provider developers.", p),
                )
                return provider{}, diags
        }

        if p == nil {
                diags.AddError(
                        "Unexpected Provider Instance Type",
                        "While creating the data source or resource, an unexpected empty provider instance was received. This is always a bug in the provider code and should be reported to the provider developers.",
                )
                return provider{}, diags
        }

        return *p, diags
}
*/
</pre>
		
		<pre class="file" id="file6" style="display: none">package ome

import (
        "context"
        "fmt"
        "net/mail"
        "strings"
        "terraform-provider-ome/clients"
        "terraform-provider-ome/models"
        "time"

        "github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
        "github.com/hashicorp/terraform-plugin-framework/attr"
        "github.com/hashicorp/terraform-plugin-framework/diag"
        "github.com/hashicorp/terraform-plugin-framework/resource"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
        "github.com/hashicorp/terraform-plugin-framework/schema/validator"
        "github.com/hashicorp/terraform-plugin-framework/types"
        "github.com/hashicorp/terraform-plugin-log/tflog"
)

const (
        //NoOFTries to get the task id
        NoOFTries = 5
)

// Ensure the implementation satisfies the expected interfaces.
var (
        _ resource.Resource                = &amp;resourceConfigurationBaseline{}
        _ resource.ResourceWithConfigure   = &amp;resourceConfigurationBaseline{}
        _ resource.ResourceWithImportState = &amp;resourceConfigurationBaseline{}
)

// NewConfigurationBaselineResource is new resource for configuration baseline
func NewConfigurationBaselineResource() resource.Resource <span class="cov8" title="1">{
        return &amp;resourceConfigurationBaseline{}
}</span>

type resourceConfigurationBaseline struct {
        p *omeProvider
}

// Configure implements resource.ResourceWithConfigure
func (r *resourceConfigurationBaseline) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) <span class="cov8" title="1">{
        if req.ProviderData == nil </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">r.p = req.ProviderData.(*omeProvider)</span>
}

// Metadata implements resource.Resource
func (r resourceConfigurationBaseline) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) <span class="cov8" title="1">{
        resp.TypeName = req.ProviderTypeName + "configuration_baseline"
}</span>

// Template Deployment Resource schema
func (r resourceConfigurationBaseline) Schema(_ context.Context, _ resource.SchemaRequest, resp *resource.SchemaResponse) <span class="cov8" title="1">{
        resp.Schema = schema.Schema{
                MarkdownDescription: "Resource for managing configuration baselines on OpenManage Enterprise. Updates are supported for all the parameters. When `schedule` is `true`, following parameters are considered: `notify_on_schedule`, `cron`, `email_addresses`, `output_format`",
                Attributes: map[string]schema.Attribute{
                        "id": schema.Int64Attribute{
                                MarkdownDescription: "ID of the configuration baseline resource.",
                                Description:         "ID of the configuration baseline resource.",
                                Computed:            true,
                        },
                        "ref_template_id": schema.Int64Attribute{
                                MarkdownDescription: "Reference template ID.",
                                Description:         "Reference template ID.",
                                Computed:            true,
                                Optional:            true,
                        },
                        "ref_template_name": schema.StringAttribute{
                                MarkdownDescription: "Reference template name.",
                                Description:         "Reference template name.",
                                Optional:            true,
                                Computed:            true,
                        },
                        "baseline_name": schema.StringAttribute{
                                MarkdownDescription: "Name of the Baseline.",
                                Description:         "Name of the Baseline.",
                                Required:            true,
                        },
                        "description": schema.StringAttribute{
                                MarkdownDescription: "Description of the baseline.",
                                Description:         "Description of the baseline.",
                                Optional:            true,
                                Computed:            true,
                        },
                        "device_ids": schema.SetAttribute{
                                MarkdownDescription: "List of the device id on which the baseline compliance needs to be run.",
                                Description:         "List of the device id on which the baseline compliance needs to be run.",
                                ElementType:         types.Int64Type,
                                Optional:            true,
                        },
                        "device_servicetags": schema.SetAttribute{
                                MarkdownDescription: "List of the device servicetag on which the baseline compliance needs to be run.",
                                Description:         "List of the device servicetag on which the baseline compliance needs to be run.",
                                ElementType:         types.StringType,
                                Optional:            true,
                        },
                        "schedule": schema.BoolAttribute{
                                MarkdownDescription: "Schedule notification via email.",
                                Description:         "Schedule notification via email.",
                                Optional:            true,
                                Computed:            true,
                                PlanModifiers: []planmodifier.Bool{
                                        BoolDefaultValue(types.BoolValue(false)),
                                },
                        },
                        "notify_on_schedule": schema.BoolAttribute{
                                MarkdownDescription: "Schedule notification via cron or any time the baseline becomes non-compliant.",
                                Description:         "Schedule notification via cron or any time the baseline becomes non-compliant.",
                                Optional:            true,
                                Computed:            true,
                                PlanModifiers: []planmodifier.Bool{
                                        BoolDefaultValue(types.BoolValue(false)),
                                },
                        },
                        "email_addresses": schema.SetAttribute{
                                MarkdownDescription: "Email addresses for notification.",
                                Description:         "Email addresses for notification.",
                                ElementType:         types.StringType,
                                Optional:            true,
                        },
                        "output_format": schema.StringAttribute{
                                MarkdownDescription: "Output format type, the input is case senitive.",
                                Description:         "Output format type, the input is case senitive.",
                                Optional:            true,
                                Computed:            true,
                                PlanModifiers: []planmodifier.String{
                                        StringDefaultValue(types.StringValue("html")),
                                },
                                Validators: []validator.String{
                                        stringvalidator.OneOf(strings.Split(clients.ValidOutputFormat, ",")...),
                                },
                        },
                        "cron": schema.StringAttribute{
                                MarkdownDescription: "Cron expression for notification schedule.",
                                Description:         "Cron expression for notification schedule.",
                                Optional:            true,
                        },
                        "task_id": schema.Int64Attribute{
                                MarkdownDescription: "Task id associated with baseline.",
                                Description:         "Task id associated with baseline.",
                                Computed:            true,
                        },
                        "job_retry_count": schema.Int64Attribute{
                                MarkdownDescription: "Number of times the job has to be polled to get the final status of the resource.",
                                Description:         "Number of times the job has to be polled to get the final status of the resource.",
                                Optional:            true,
                                Computed:            true,
                                PlanModifiers: []planmodifier.Int64{
                                        Int64DefaultValue(types.Int64Value(30)),
                                },
                        },
                        "sleep_interval": schema.Int64Attribute{
                                MarkdownDescription: "Sleep time interval for job polling in seconds.",
                                Description:         "Sleep time interval for job polling in seconds.",
                                Optional:            true,
                                Computed:            true,
                                PlanModifiers: []planmodifier.Int64{
                                        Int64DefaultValue(types.Int64Value(20)),
                                },
                        },
                },
        }
}</span>

// Create a new resource
func (r resourceConfigurationBaseline) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) <span class="cov8" title="1">{
        //Get Plan Data
        tflog.Trace(ctx, "resource_configuration_baseline create: started")
        var plan models.ConfigureBaselines
        diags := req.Plan.Get(ctx, &amp;plan)
        resp.Diagnostics.Append(diags...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">state := models.ConfigureBaselines{}

        err := validateNotification(plan)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        clients.ErrCreateClient,
                        err.Error(),
                )
                return
        }</span>
        //Create Session and defer the remove session
        <span class="cov8" title="1">omeClient, err := clients.NewClient(*r.p.clientOpt)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        clients.ErrCreateClient,
                        err.Error(),
                )
                return
        }</span>

        <span class="cov8" title="1">tflog.Trace(ctx, "resource_configuration_baseline create Creating Session")
        _, err = omeClient.CreateSession()
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        clients.ErrCreateSession,
                        err.Error(),
                )
                return
        }</span>
        <span class="cov8" title="1">defer omeClient.RemoveSession()

        tflog.Info(ctx, "resource_configuration_baseline create Validating Template Details")
        omeTemplate, err := validateRefTemplateDetails(plan.RefTemplateID.ValueInt64(), plan.RefTemplateName.ValueString(), omeClient)
        if err != nil </span><span class="cov8" title="1">{
                resp.Diagnostics.AddError(
                        clients.ErrGnrCreateBaseline,
                        err.Error(),
                )
                return
        }</span>

        <span class="cov8" title="1">var serviceTags []string
        var devIDs []int64

        diags = plan.DeviceServicetags.ElementsAs(ctx, &amp;serviceTags, true)
        if diags.HasError() </span><span class="cov0" title="0">{
                resp.Diagnostics.Append(diags...)
                return
        }</span>

        <span class="cov8" title="1">diags = plan.DeviceIDs.ElementsAs(ctx, &amp;devIDs, true)
        if diags.HasError() </span><span class="cov0" title="0">{
                resp.Diagnostics.Append(diags...)
                return
        }</span>

        <span class="cov8" title="1">tflog.Info(ctx, "resource_configuration_baseline create Validating device details")
        targetDevices, usedDeviceInput, err := getValidTargetDevices(omeClient, serviceTags, devIDs)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        clients.ErrGnrCreateBaseline,
                        err.Error(),
                )
                return
        }</span>

        <span class="cov8" title="1">cb, err := getPayload(ctx, &amp;plan, omeTemplate.ID, targetDevices)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        clients.ErrGnrCreateBaseline, err.Error(),
                )
                return
        }</span>

        <span class="cov8" title="1">tflog.Trace(ctx, "resource_configuration_baseline create Creating Baseline")
        tflog.Debug(ctx, "resource_configuration_baseline create Creating Baseline", map[string]interface{}{
                "Create Baseline Request": cb,
        })

        cBaseline, err := omeClient.CreateBaseline(cb)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        clients.ErrGnrCreateBaseline, err.Error(),
                )
                return
        }</span>

        <span class="cov8" title="1">tflog.Trace(ctx, "resource_configuration_baseline : create Finished creating Baseline")

        tflog.Trace(ctx, "resource_configuration_baseline : create Fetching task id for a baseline")

        baseline, err := getLatestBaseline(omeClient, cBaseline.ID)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        clients.ErrGnrCreateBaseline, err.Error(),
                )
                return
        }</span>
        <span class="cov8" title="1">tflog.Debug(ctx, "resource_configuration_baseline : create Baseline created ", map[string]interface{}{
                "baselineid": baseline.ID,
                "taskid":     baseline.TaskID,
        })

        isSuccess, message := omeClient.TrackJob(baseline.TaskID, plan.JobRetryCount.ValueInt64(), plan.SleepInterval.ValueInt64())
        if !isSuccess </span><span class="cov0" title="0">{
                resp.Diagnostics.AddWarning(
                        clients.ErrBaselineCreationTask, message,
                )
        }</span>

        <span class="cov8" title="1">tflog.Trace(ctx, "resource_configuration_baseline Done Track Job", map[string]interface{}{
                "TaskID": fmt.Sprint(baseline.TaskID),
        })

        // Save into State
        updateBaselineState(ctx, &amp;state, &amp;plan, baseline, usedDeviceInput, omeClient)

        diags = resp.State.Set(ctx, &amp;state)
        resp.Diagnostics.Append(diags...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>
}

// Read resource information
func (r resourceConfigurationBaseline) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) <span class="cov8" title="1">{
        //Get State Data
        var state models.ConfigureBaselines
        diags := req.State.Get(ctx, &amp;state)
        resp.Diagnostics.Append(diags...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        //Create Session and differ the remove session
        <span class="cov8" title="1">omeClient, err := clients.NewClient(*r.p.clientOpt)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        clients.ErrCreateClient,
                        err.Error(),
                )
                return
        }</span>

        <span class="cov8" title="1">_, err = omeClient.CreateSession()
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        clients.ErrCreateSession,
                        err.Error(),
                )
                return
        }</span>
        <span class="cov8" title="1">defer omeClient.RemoveSession()

        var usedDeviceInput string

        if len(state.DeviceIDs.Elements()) &gt; 0 </span><span class="cov8" title="1">{
                usedDeviceInput = clients.DeviceIDs
        }</span> else<span class="cov8" title="1"> if len(state.DeviceServicetags.Elements()) &gt; 0 </span><span class="cov8" title="1">{
                usedDeviceInput = clients.ServiceTags
        }</span>
        <span class="cov8" title="1">baseline, err := omeClient.GetBaselineByID(state.ID.ValueInt64())
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        clients.ErrGnrReadBaseline, err.Error(),
                )
                return
        }</span>

        <span class="cov8" title="1">updateBaselineState(ctx, &amp;state, &amp;state, baseline, usedDeviceInput, omeClient)
        //Save into State
        diags = resp.State.Set(ctx, &amp;state)
        resp.Diagnostics.Append(diags...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>
}

// Update resource
func (r resourceConfigurationBaseline) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) <span class="cov8" title="1">{
        //Get state Data
        var state models.ConfigureBaselines
        diags := req.State.Get(ctx, &amp;state)
        resp.Diagnostics.Append(diags...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        // Get plan Data
        <span class="cov8" title="1">var plan models.ConfigureBaselines
        diags = req.Plan.Get(ctx, &amp;plan)
        resp.Diagnostics.Append(diags...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">err := validateNotification(plan)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        clients.ErrCreateClient,
                        err.Error(),
                )
                return
        }</span>

        //Create Session and differ the remove session
        <span class="cov8" title="1">omeClient, err := clients.NewClient(*r.p.clientOpt)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        clients.ErrCreateClient,
                        err.Error(),
                )
                return
        }</span>

        <span class="cov8" title="1">_, err = omeClient.CreateSession()
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        clients.ErrCreateSession,
                        err.Error(),
                )
                return
        }</span>
        <span class="cov8" title="1">defer omeClient.RemoveSession()

        tflog.Trace(ctx, "resource_configuration_baseline update checking the job status")
        tflog.Debug(ctx, "resource_configuration_baseline checking job status for", map[string]interface{}{
                "jobid": state.TaskID.ValueInt64(),
        })

        if state.TaskID.ValueInt64() != 0 </span><span class="cov8" title="1">{
                jr, err := omeClient.GetJob(state.TaskID.ValueInt64())
                if err != nil </span><span class="cov0" title="0">{
                        resp.Diagnostics.AddError(
                                clients.ErrGnrUpdateBaseline,
                                err.Error(),
                        )
                        return
                }</span>
                <span class="cov8" title="1">tflog.Debug(ctx, "resource_configuration_baseline update job status is", map[string]interface{}{
                        "jobid":  state.TaskID.ValueInt64(),
                        "status": jr.LastRunStatus.ID,
                })

                //if job is running during update, throw error
                if jr.LastRunStatus.ID == clients.RunningStatusID </span><span class="cov0" title="0">{
                        resp.Diagnostics.AddError(
                                clients.ErrGnrUpdateBaseline,
                                clients.ErrBaseLineJobIsRunning,
                        )
                        return
                }</span>
        }

        <span class="cov8" title="1">tflog.Info(ctx, "resource_configuration_baseline update Validating Template Details")
        omeTemplate, err := validateRefTemplateDetails(plan.RefTemplateID.ValueInt64(), plan.RefTemplateName.ValueString(), omeClient)
        if err != nil </span><span class="cov8" title="1">{
                resp.Diagnostics.AddError(
                        clients.ErrGnrUpdateBaseline,
                        err.Error(),
                )
                return
        }</span>

        <span class="cov8" title="1">var serviceTags []string
        var devIDs []int64

        diags = plan.DeviceServicetags.ElementsAs(ctx, &amp;serviceTags, true)
        if diags.HasError() </span><span class="cov0" title="0">{
                resp.Diagnostics.Append(diags...)
                return
        }</span>

        <span class="cov8" title="1">diags = plan.DeviceIDs.ElementsAs(ctx, &amp;devIDs, true)
        if diags.HasError() </span><span class="cov0" title="0">{
                resp.Diagnostics.Append(diags...)
                return
        }</span>

        <span class="cov8" title="1">tflog.Info(ctx, "resource_configuration_baseline update Validating device details")

        targetDevices, usedDeviceInput, err := getValidTargetDevices(omeClient, serviceTags, devIDs)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        clients.ErrGnrUpdateBaseline,
                        err.Error(),
                )
                return
        }</span>

        <span class="cov8" title="1">cb, err := getPayload(ctx, &amp;plan, omeTemplate.ID, targetDevices)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        clients.ErrGnrUpdateBaseline, err.Error(),
                )
                return
        }</span>
        <span class="cov8" title="1">cb.ID = state.ID.ValueInt64() // For update case

        tflog.Trace(ctx, "resource_configuration_baseline update Creating Baseline")
        tflog.Debug(ctx, "resource_configuration_baseline update Creating Baseline", map[string]interface{}{
                "Create Baseline Request": cb,
        })

        uBaseline, err := omeClient.UpdateBaseline(cb)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        clients.ErrGnrUpdateBaseline, err.Error(),
                )
                return
        }</span>

        <span class="cov8" title="1">tflog.Trace(ctx, "resource_configuration_baseline : update Finished creating Baseline")

        tflog.Trace(ctx, "resource_configuration_baseline : update Fetching task id for a baseline")

        baseline, err := getLatestBaseline(omeClient, uBaseline.ID)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        clients.ErrGnrUpdateBaseline, err.Error(),
                )
                return
        }</span>
        <span class="cov8" title="1">tflog.Debug(ctx, "resource_configuration_baseline : update Baseline created ", map[string]interface{}{
                "baselineid": baseline.ID,
                "taskid":     baseline.TaskID,
        })

        isSuccess, message := omeClient.TrackJob(baseline.TaskID, plan.JobRetryCount.ValueInt64(), plan.SleepInterval.ValueInt64())
        if !isSuccess </span><span class="cov0" title="0">{
                resp.Diagnostics.AddWarning(
                        clients.ErrBaselineCreationTask, message,
                )
        }</span>

        <span class="cov8" title="1">tflog.Trace(ctx, "resource_configuration_baseline update Done Track Job", map[string]interface{}{
                "TaskID": fmt.Sprint(baseline.TaskID),
        })

        // Save into State
        updateBaselineState(ctx, &amp;state, &amp;plan, baseline, usedDeviceInput, omeClient)

        //Save into State
        diags = resp.State.Set(ctx, &amp;state)
        resp.Diagnostics.Append(diags...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>
}

// Delete resource
func (r resourceConfigurationBaseline) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) <span class="cov8" title="1">{
        // Get State Data
        var state models.ConfigureBaselines
        diags := req.State.Get(ctx, &amp;state)
        resp.Diagnostics.Append(diags...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        //Create Session and differ the remove session
        <span class="cov8" title="1">omeClient, err := clients.NewClient(*r.p.clientOpt)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        clients.ErrCreateClient,
                        err.Error(),
                )
                return
        }</span>

        <span class="cov8" title="1">_, err = omeClient.CreateSession()
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        clients.ErrCreateSession,
                        err.Error(),
                )
                return
        }</span>
        <span class="cov8" title="1">defer omeClient.RemoveSession()

        err = omeClient.DeleteBaseline([]int64{state.ID.ValueInt64()})

        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        clients.ErrGnrDeleteBaseline,
                        err.Error(),
                )
        }</span>
        <span class="cov8" title="1">resp.State.RemoveResource(ctx)</span>
}

// Import resource
func (r resourceConfigurationBaseline) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) <span class="cov8" title="1">{
        // Save the import identifier in the id attribute
        var state models.ConfigureBaselines
        baselineName := req.ID

        omeClient, err := clients.NewClient(*r.p.clientOpt)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        clients.ErrCreateClient,
                        err.Error(),
                )
                return
        }</span>

        <span class="cov8" title="1">_, err = omeClient.CreateSession()
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        clients.ErrCreateSession,
                        err.Error(),
                )
                return
        }</span>

        <span class="cov8" title="1">defer omeClient.RemoveSession()

        baseline, err := omeClient.GetBaselineByName(baselineName)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(clients.ErrImportDeployment, err.Error())
                return
        }</span>
        <span class="cov8" title="1">dia := updateBaselineState(ctx, &amp;state, &amp;state, baseline, clients.ServiceTags, omeClient)
        resp.Diagnostics.Append(dia...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>
        //Save into State
        <span class="cov8" title="1">if len(state.EmailAddresses.Elements()) == 0 </span><span class="cov8" title="1">{
                state.EmailAddresses, _ = types.SetValue(types.StringType, nil)
        }</span>
        <span class="cov8" title="1">if len(state.DeviceIDs.Elements()) == 0 </span><span class="cov8" title="1">{
                state.DeviceIDs, _ = types.SetValue(types.Int64Type, nil)
        }</span>
        <span class="cov8" title="1">state.OutputFormat = types.StringValue("html")
        state.JobRetryCount = types.Int64Value(30)
        state.SleepInterval = types.Int64Value(20)

        diags := resp.State.Set(ctx, &amp;state)
        resp.Diagnostics.Append(diags...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>
}

func validateRefTemplateDetails(refTemplateID int64, refTemplateName string, omeClient *clients.Client) (models.OMETemplate, error) <span class="cov8" title="1">{
        if refTemplateID == 0 &amp;&amp; refTemplateName == "" </span><span class="cov8" title="1">{
                return models.OMETemplate{}, fmt.Errorf(clients.ErrInvalidRefTemplateNameorID)
        }</span>
        <span class="cov8" title="1">if refTemplateID &gt; 0 &amp;&amp; refTemplateName != "" </span><span class="cov8" title="1">{
                return models.OMETemplate{}, fmt.Errorf(clients.ErrInvalidRefTemplateNameorID)
        }</span>
        <span class="cov8" title="1">omeTemplate, err := omeClient.GetTemplateByIDOrName(refTemplateID, refTemplateName)
        if err != nil </span><span class="cov0" title="0">{
                return models.OMETemplate{}, err
        }</span>
        <span class="cov8" title="1">if omeTemplate.ViewTypeID != ComplianceViewTypeID </span><span class="cov8" title="1">{
                return models.OMETemplate{}, fmt.Errorf(clients.ErrInvalidRefTemplateType)
        }</span>
        <span class="cov8" title="1">return omeTemplate, nil</span>
}

func validateDevicesCapablity(deviceIds []int64, deviceServiceTags []string, omeClient *clients.Client) ([]models.Device, error) <span class="cov8" title="1">{
        var invalidDevices []models.Device
        devices, err := omeClient.GetDevices(deviceServiceTags, deviceIds, []string{})
        if err != nil </span><span class="cov0" title="0">{
                return []models.Device{}, err
        }</span>
        <span class="cov8" title="1">for _, device := range devices </span><span class="cov8" title="1">{
                validDevice := false
                for _, deviceCapability := range device.DeviceCapabilities </span><span class="cov8" title="1">{
                        if deviceCapability == 33 </span><span class="cov8" title="1">{
                                validDevice = true
                                break</span>
                        }
                }
                <span class="cov8" title="1">if !validDevice </span><span class="cov0" title="0">{
                        invalidDevices = append(invalidDevices, device)
                }</span>
        }
        <span class="cov8" title="1">if len(invalidDevices) != 0 </span><span class="cov0" title="0">{
                return []models.Device{}, fmt.Errorf(clients.ErrDeviceNotCapable, invalidDevices)
        }</span>
        <span class="cov8" title="1">return devices, nil</span>
}

func updateBaselineState(ctx context.Context, state *models.ConfigureBaselines, plan *models.ConfigureBaselines, omeBaseline models.OmeBaseline, usedDeviceInput string, omeClient *clients.Client) (dia diag.Diagnostics) <span class="cov8" title="1">{
        state.ID = types.Int64Value(omeBaseline.ID)
        state.RefTemplateID = types.Int64Value(omeBaseline.TemplateID)
        state.RefTemplateName = types.StringValue(omeBaseline.TemplateName)
        state.Description = types.StringValue(omeBaseline.Description)
        state.BaselineName = types.StringValue(omeBaseline.Name)

        if usedDeviceInput == clients.ServiceTags </span><span class="cov8" title="1">{
                apiDeviceIDs := map[string]models.Device{}
                devSts := []string{}
                deviceStVals := []attr.Value{}
                for _, bTarget := range omeBaseline.BaselineTargets </span><span class="cov8" title="1">{
                        device, _ := omeClient.GetDevice("", bTarget.ID)
                        apiDeviceIDs[device.DeviceServiceTag] = device
                }</span>

                <span class="cov8" title="1">if len(plan.DeviceServicetags.Elements()) &gt; 0 </span><span class="cov8" title="1">{
                        plan.DeviceServicetags.ElementsAs(ctx, &amp;devSts, true)
                }</span>

                <span class="cov8" title="1">for _, devSt := range devSts </span><span class="cov8" title="1">{
                        if val, ok := apiDeviceIDs[devSt]; ok </span><span class="cov8" title="1">{
                                deviceStVals = append(deviceStVals, types.StringValue(val.DeviceServiceTag))
                                delete(apiDeviceIDs, devSt)
                        }</span>
                }

                <span class="cov8" title="1">if len(apiDeviceIDs) != 0 </span><span class="cov8" title="1">{
                        for _, val := range apiDeviceIDs </span><span class="cov8" title="1">{
                                deviceStVals = append(deviceStVals, types.StringValue(val.DeviceServiceTag))
                        }</span>
                }

                <span class="cov8" title="1">devSTsTfsdk, _ := types.SetValue(
                        types.StringType,
                        deviceStVals,
                )
                state.DeviceServicetags = devSTsTfsdk
                state.DeviceIDs = plan.DeviceIDs</span>
        } else<span class="cov8" title="1"> {
                apiDeviceIDs := map[int64]models.Device{}
                devIDs := []int64{}
                deviceIDVals := []attr.Value{}
                for _, bTarget := range omeBaseline.BaselineTargets </span><span class="cov8" title="1">{
                        device, _ := omeClient.GetDevice("", bTarget.ID)
                        apiDeviceIDs[device.ID] = device
                }</span>

                <span class="cov8" title="1">plan.DeviceIDs.ElementsAs(ctx, &amp;devIDs, true)

                for _, devID := range devIDs </span><span class="cov8" title="1">{
                        if val, ok := apiDeviceIDs[devID]; ok </span><span class="cov8" title="1">{
                                deviceIDVals = append(deviceIDVals, types.Int64Value(val.ID))
                                delete(apiDeviceIDs, devID)
                        }</span>
                }

                <span class="cov8" title="1">if len(apiDeviceIDs) != 0 </span><span class="cov0" title="0">{
                        for _, val := range apiDeviceIDs </span><span class="cov0" title="0">{
                                deviceIDVals = append(deviceIDVals, types.Int64Value(val.ID))
                        }</span>
                }

                <span class="cov8" title="1">devIDsTfsdk, _ := types.SetValue(types.Int64Type, deviceIDVals)
                state.DeviceIDs = devIDsTfsdk
                state.DeviceServicetags = plan.DeviceServicetags</span>
        }

        <span class="cov8" title="1">notificationSettings := omeBaseline.NotificationSettings
        if notificationSettings != nil </span><span class="cov8" title="1">{
                state.Schedule = types.BoolValue(true)
                state.OutputFormat = types.StringValue(notificationSettings.OutputFormat)

                emailAddress := []attr.Value{}
                for _, v := range notificationSettings.EmailAddresses </span><span class="cov8" title="1">{
                        emailAddress = append(emailAddress, types.StringValue(v))
                }</span>

                <span class="cov8" title="1">emailTfsdk, emailerror := types.SetValue(types.StringType, emailAddress)
                dia.Append(emailerror...)
                state.EmailAddresses = emailTfsdk

                if notificationSettings.NotificationType == "NOTIFY_ON_NON_COMPLIANCE" </span><span class="cov8" title="1">{
                        state.NotifyOnSchedule = types.BoolValue(false)
                }</span> else<span class="cov8" title="1"> {
                        state.NotifyOnSchedule = types.BoolValue(true)
                }</span>

                <span class="cov8" title="1">if notificationSettings.Schedule.Cron != "" </span><span class="cov8" title="1">{
                        state.Cron = types.StringValue(notificationSettings.Schedule.Cron)
                }</span> else<span class="cov8" title="1"> {
                        state.Cron = plan.Cron
                }</span>
        } else<span class="cov8" title="1"> {
                state.Schedule = plan.Schedule
                state.NotifyOnSchedule = plan.NotifyOnSchedule
                state.EmailAddresses = plan.EmailAddresses
                state.OutputFormat = plan.OutputFormat
                state.Cron = plan.Cron

        }</span>
        <span class="cov8" title="1">state.TaskID = types.Int64Value(omeBaseline.TaskID)
        state.JobRetryCount = plan.JobRetryCount
        state.SleepInterval = plan.SleepInterval
        return</span>
}

func getPayload(ctx context.Context, plan *models.ConfigureBaselines, templateID int64, targetDevices []models.Device) (models.ConfigurationBaselinePayload, error) <span class="cov8" title="1">{
        cbp := models.ConfigurationBaselinePayload{
                Name:        plan.BaselineName.ValueString(),
                Description: plan.Description.ValueString(),
                TemplateID:  templateID,
        }

        var baselineTargets []models.BaselineTarget
        for _, tDevices := range targetDevices </span><span class="cov8" title="1">{
                baselineTarget := models.BaselineTarget{
                        ID: tDevices.ID,
                        Type: models.BaselineTargetType{
                                ID:   1,
                                Name: "DEVICE",
                        },
                }
                baselineTargets = append(baselineTargets, baselineTarget)
        }</span>
        <span class="cov8" title="1">cbp.BaselineTargets = baselineTargets

        if plan.Schedule.ValueBool() </span><span class="cov8" title="1">{
                if len(plan.EmailAddresses.Elements()) == 0 </span><span class="cov0" title="0">{
                        return models.ConfigurationBaselinePayload{}, fmt.Errorf(clients.ErrScheduleNotification)
                }</span>
                <span class="cov8" title="1">var emailaddressList []string
                plan.EmailAddresses.ElementsAs(ctx, &amp;emailaddressList, true)
                for _, emailAddress := range emailaddressList </span><span class="cov8" title="1">{
                        _, err := mail.ParseAddress(emailAddress)
                        if err != nil </span><span class="cov0" title="0">{
                                return models.ConfigurationBaselinePayload{}, fmt.Errorf(clients.ErrInvalidEmailAddress, emailAddress)
                        }</span>
                }

                <span class="cov8" title="1">if plan.NotifyOnSchedule.ValueBool() &amp;&amp; plan.Cron.ValueString() == "" </span><span class="cov0" title="0">{
                        return models.ConfigurationBaselinePayload{}, fmt.Errorf(clients.ErrInvalidCronExpression)
                }</span>

                <span class="cov8" title="1">notificationType := "NOTIFY_ON_NON_COMPLIANCE"
                if plan.NotifyOnSchedule.ValueBool() </span><span class="cov8" title="1">{
                        notificationType = "NOTIFY_ON_SCHEDULE"
                }</span>

                <span class="cov8" title="1">notificationSettings := models.NotificationSettings{
                        NotificationType: notificationType,
                        EmailAddresses:   emailaddressList,
                        Schedule: models.BaselineNotificationSchedule{
                                Cron: plan.Cron.ValueString(),
                        },
                        OutputFormat: strings.ToUpper(plan.OutputFormat.ValueString()),
                }
                cbp.NotificationSettings = &amp;notificationSettings</span>
        }

        <span class="cov8" title="1">return cbp, nil</span>
}

func getLatestBaseline(omeClient *clients.Client, baselineID int64) (models.OmeBaseline, error) <span class="cov8" title="1">{
        retries := 1
        var taskID int64 = 0
        var baseline models.OmeBaseline
        var err error
        for taskID == 0 &amp;&amp; retries != NoOFTries </span><span class="cov8" title="1">{
                time.Sleep(3 * time.Second)
                retries = retries + 1
                baseline, err = omeClient.GetBaselineByID(baselineID)
                if err != nil </span><span class="cov0" title="0">{
                        return models.OmeBaseline{}, err
                }</span>
                <span class="cov8" title="1">taskID = baseline.TaskID</span>
        }
        <span class="cov8" title="1">return baseline, nil</span>
}

func getValidTargetDevices(omeClient *clients.Client, serviceTags []string, devIDs []int64) ([]models.Device, string, error) <span class="cov8" title="1">{
        usedDeviceInput, err := clients.DeviceMutuallyExclusive(serviceTags, devIDs)
        if err != nil </span><span class="cov0" title="0">{
                return []models.Device{}, "", err
        }</span>

        //Check if the Devices has a capablity 33 (ome advance license)
        <span class="cov8" title="1">targetDevices, err := validateDevicesCapablity(devIDs, serviceTags, omeClient)
        if err != nil </span><span class="cov0" title="0">{
                return []models.Device{}, "", err
        }</span>
        <span class="cov8" title="1">return targetDevices, usedDeviceInput, err</span>
}

func validateNotification(plan models.ConfigureBaselines) error <span class="cov8" title="1">{
        if !plan.Schedule.ValueBool() </span><span class="cov8" title="1">{
                if !plan.Cron.IsNull() || !plan.EmailAddresses.IsNull() </span><span class="cov0" title="0">{
                        return fmt.Errorf(clients.ErrBaseLineScheduleValid)
                }</span>
        } else<span class="cov8" title="1"> {
                if !plan.NotifyOnSchedule.ValueBool() &amp;&amp; !plan.Cron.IsNull() </span><span class="cov0" title="0">{
                        return fmt.Errorf(clients.ErrBaseLineNotifyValid)
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package ome

import (
        "context"
        "fmt"
        "strings"
        "terraform-provider-ome/clients"
        "terraform-provider-ome/models"
        "time"

        "github.com/hashicorp/terraform-plugin-framework/resource"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
        "github.com/hashicorp/terraform-plugin-framework/schema/validator"
        "github.com/hashicorp/terraform-plugin-framework/types"
        "github.com/hashicorp/terraform-plugin-log/tflog"
)

const (
        //NoOfTriesToGetBaselineStatus to get the task id
        NoOfTriesToGetBaselineStatus = 12
        //NotInventoried to identify is the baseline is inventored
        NotInventoried = "NOT_INVENTORIED"
        //Compliant - status compliant
        Compliant = "Compliant"
        //NonCompliant - status non compliant
        NonCompliant = "Non Compliant"
)

// Ensure the implementation satisfies the expected interfaces.
var (
        _ resource.Resource                = &amp;resourceConfigurationCompliance{}
        _ resource.ResourceWithConfigure   = &amp;resourceConfigurationCompliance{}
        _ resource.ResourceWithImportState = &amp;resourceConfigurationCompliance{}
)

// NewConfigurationComplianceResource is a new resource for configuration compliance
func NewConfigurationComplianceResource() resource.Resource <span class="cov8" title="1">{
        return &amp;resourceConfigurationCompliance{}
}</span>

type resourceConfigurationCompliance struct {
        p *omeProvider
}

// Configure implements resource.ResourceWithConfigure
func (r *resourceConfigurationCompliance) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) <span class="cov8" title="1">{
        if req.ProviderData == nil </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">r.p = req.ProviderData.(*omeProvider)</span>
}

// Metadata implements resource.Resource
func (*resourceConfigurationCompliance) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) <span class="cov8" title="1">{
        resp.TypeName = req.ProviderTypeName + "configuration_compliance"
}</span>

func (r resourceConfigurationCompliance) Schema(_ context.Context, _ resource.SchemaRequest, resp *resource.SchemaResponse) <span class="cov8" title="1">{
        resp.Schema = schema.Schema{
                Version:             1,
                MarkdownDescription: "Resource for managing configuration baselines remediation. Updates are supported for the following parameters: `target_devices`, `job_retry_count`, `sleep_interval`, `run_later`, `cron`.",
                Attributes: map[string]schema.Attribute{
                        "id": schema.StringAttribute{
                                MarkdownDescription: "ID of the configuration compliance resource.",
                                Description:         "ID of the configuration compliance resource.",
                                Computed:            true,
                        },
                        "baseline_name": schema.StringAttribute{
                                MarkdownDescription: "Name of the Baseline.",
                                Description:         "Name of the Baseline.",
                                Optional:            true,
                                Computed:            true,
                        },
                        "baseline_id": schema.Int64Attribute{
                                MarkdownDescription: "Id of the Baseline.",
                                Description:         "Id of the Baseline.",
                                Optional:            true,
                                Computed:            true,
                        },
                        "target_devices": schema.SetNestedAttribute{
                                MarkdownDescription: "Target devices to be remediated.",
                                Description:         "Target devices to be remediated.",
                                Required:            true,
                                NestedObject: schema.NestedAttributeObject{
                                        Attributes: map[string]schema.Attribute{
                                                "device_service_tag": schema.StringAttribute{
                                                        MarkdownDescription: "Target device servicetag to be remediated.",
                                                        Description:         "Target device servicetag to be remediated.",
                                                        Required:            true,
                                                },
                                                "compliance_status": schema.StringAttribute{
                                                        MarkdownDescription: "End compliance status of the target device, used to check the drifts in the compliance status.",
                                                        Description:         "End compliance status of the target device, used to check the drifts in the compliance status.",
                                                        Required:            true,
                                                        Validators: []validator.String{
                                                                complianceStateValidator{},
                                                        },
                                                },
                                        },
                                },
                                Validators: []validator.Set{
                                        sizeAtLeastValidator{min: 1},
                                },
                        },
                        "job_retry_count": schema.Int64Attribute{
                                MarkdownDescription: "Number of times the job has to be polled to get the final status of the resource.",
                                Description:         "Number of times the job has to be polled to get the final status of the resource.",
                                Optional:            true,
                                Computed:            true,
                                PlanModifiers: []planmodifier.Int64{
                                        Int64DefaultValue(types.Int64Value(30)),
                                },
                        },
                        "sleep_interval": schema.Int64Attribute{
                                MarkdownDescription: "Sleep time interval for job polling in seconds.",
                                Description:         "Sleep time interval for job polling in seconds.",
                                Optional:            true,
                                Computed:            true,
                                PlanModifiers: []planmodifier.Int64{
                                        Int64DefaultValue(types.Int64Value(20)),
                                },
                        },
                        "run_later": schema.BoolAttribute{
                                MarkdownDescription: "Provides options to schedule the remediation task immediately, or at a specified time.",
                                Description:         "Provides options to schedule the remediation task immediately, or at a specified time.",
                                Optional:            true,
                        },
                        "cron": schema.StringAttribute{
                                MarkdownDescription: "Cron to schedule the remediation task.",
                                Description:         "Cron to schedule the remediation task.",
                                Optional:            true,
                        },
                },
        }
}</span>

// Create a new resource
func (r resourceConfigurationCompliance) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) <span class="cov8" title="1">{
        //Get Plan Data
        tflog.Trace(ctx, "resource_configuration_compliance: create started")
        var plan models.ConfigurationRemediation
        diags := req.Plan.Get(ctx, &amp;plan)
        resp.Diagnostics.Append(diags...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                fmt.Println(clients.ErrPlanToTfsdkConversion)
                return
        }</span>
        <span class="cov8" title="1">if plan.RunLater.ValueBool() &amp;&amp; plan.Cron.ValueString() == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        clients.ErrGnrBaseLineCreateRemediation,
                        clients.ErrCronRequired,
                )
                return
        }</span>

        <span class="cov8" title="1">state := models.ConfigurationRemediation{}

        //Create Session and defer the remove session
        omeClient, err := clients.NewClient(*r.p.clientOpt)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        clients.ErrCreateClient,
                        err.Error(),
                )
                return
        }</span>

        <span class="cov8" title="1">tflog.Trace(ctx, "resource_configuration_compliance: create Creating Session")
        _, err = omeClient.CreateSession()
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        clients.ErrCreateSession,
                        err.Error(),
                )
                return
        }</span>
        <span class="cov8" title="1">defer omeClient.RemoveSession()

        baseline, err := checkValidBaseline(omeClient, plan.BaselineName.ValueString(), plan.BaselineID.ValueInt64(), false)
        if err != nil </span><span class="cov8" title="1">{
                resp.Diagnostics.AddError(
                        clients.ErrGnrBaseLineCreateRemediation,
                        err.Error(),
                )
                return
        }</span>

        <span class="cov8" title="1">tflog.Trace(ctx, "resource_configuration_compliance create: all baselines data is valid")
        var targetDevices []string
        for _, td := range plan.TargetDevices </span><span class="cov8" title="1">{
                targetDevices = append(targetDevices, td.DeviceServiceTag.ValueString())
        }</span>

        <span class="cov8" title="1">targetDeviceIDs, err := checkValidDevices(omeClient, targetDevices, baseline)
        if err != nil </span><span class="cov8" title="1">{
                resp.Diagnostics.AddError(
                        clients.ErrGnrBaseLineCreateRemediation,
                        err.Error(),
                )
                return
        }</span>
        <span class="cov8" title="1">tflog.Trace(ctx, "resource_configuration_compliance create: all target devices are valid")

        crp := getRemediationPayload(baseline.ID, targetDeviceIDs, plan.RunLater.ValueBool(), plan.Cron.ValueString())

        tflog.Trace(ctx, "resource_configuration_compliance create: triggered remediation", map[string]interface{}{
                "payload": crp,
        })

        jobID, err := omeClient.RemediateBaseLineDevices(crp)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        clients.ErrGnrBaseLineCreateRemediation,
                        err.Error(),
                )
                return
        }</span>

        <span class="cov8" title="1">tflog.Trace(ctx, "resource_configuration_compliance create: Job created", map[string]interface{}{
                "jobID": jobID,
        })
        if jobID != 0 &amp;&amp; !plan.RunLater.ValueBool() </span><span class="cov8" title="1">{
                tflog.Trace(ctx, "resource_configuration_compliance create: Job track started")
                isSuccess, err := omeClient.TrackJob(jobID, plan.JobRetryCount.ValueInt64(), plan.SleepInterval.ValueInt64())
                if !isSuccess </span><span class="cov0" title="0">{
                        tflog.Trace(ctx, "resource_configuration_compliance create: Job track errored", map[string]interface{}{
                                "err": err,
                        })
                        resp.Diagnostics.AddError(
                                clients.ErrGnrBaseLineCreateRemediation,
                                err,
                        )
                }</span>
        }

        <span class="cov8" title="1">tflog.Trace(ctx, "resource_configuration_compliance create: saving state")
        state = plan
        state.BaselineID = types.Int64Value(baseline.ID)
        state.BaselineName = types.StringValue(baseline.Name)
        state.ID = types.StringValue(fmt.Sprintf("%d", baseline.ID))

        //save the data into state
        diags = resp.State.Set(ctx, &amp;state)
        resp.Diagnostics.Append(diags...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">tflog.Trace(ctx, "resource_configuration_compliance create: create finished")</span>
}

// Read resource information
func (r resourceConfigurationCompliance) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) <span class="cov8" title="1">{
        //Get State Data
        tflog.Trace(ctx, "resource_configuration_compliance: read started")
        var state models.ConfigurationRemediation
        diags := req.State.Get(ctx, &amp;state)
        resp.Diagnostics.Append(diags...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        //Create Session and differ the remove session
        <span class="cov8" title="1">omeClient, err := clients.NewClient(*r.p.clientOpt)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        clients.ErrCreateClient,
                        err.Error(),
                )
                return
        }</span>

        <span class="cov8" title="1">_, err = omeClient.CreateSession()
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        clients.ErrCreateSession,
                        err.Error(),
                )
                return
        }</span>
        <span class="cov8" title="1">defer omeClient.RemoveSession()

        tflog.Trace(ctx, "resource_configuration_compliance: read checking status report")
        //check the compliance status to check if the reports are generated
        err = checkReportsStatus(omeClient, state.BaselineID.ValueInt64())
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        clients.ErrGnrBaseLineReadRemediation,
                        err.Error(),
                )
                return
        }</span>

        <span class="cov8" title="1">tflog.Trace(ctx, "resource_configuration_compliance: read checking status finshed")

        for i, td := range state.TargetDevices </span><span class="cov8" title="1">{
                deviceReport, err := omeClient.GetConfiBaselineDeviceReport(state.BaselineID.ValueInt64(), td.DeviceServiceTag.ValueString())
                if err != nil </span><span class="cov0" title="0">{
                        if err != nil </span><span class="cov0" title="0">{
                                resp.Diagnostics.AddError(
                                        clients.ErrGnrBaseLineReadRemediation,
                                        err.Error(),
                                )
                                return
                        }</span>
                }
                <span class="cov8" title="1">compliantStatus := Compliant
                if deviceReport.ComplianceStatus != 1 </span><span class="cov8" title="1">{
                        compliantStatus = NonCompliant
                }</span>
                <span class="cov8" title="1">state.TargetDevices[i] = models.TargetDevices{
                        DeviceServiceTag: td.DeviceServiceTag,
                        ComplianceStatus: types.StringValue(compliantStatus),
                }</span>
        }

        //Save into State
        <span class="cov8" title="1">diags = resp.State.Set(ctx, &amp;state)
        resp.Diagnostics.Append(diags...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">tflog.Trace(ctx, "resource_configuration_compliance: read finished")</span>
}

// Update resource
func (r resourceConfigurationCompliance) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) <span class="cov8" title="1">{
        //Get state Data
        tflog.Trace(ctx, "resource_configuration_compliance: update started")
        var state models.ConfigurationRemediation
        diags := req.State.Get(ctx, &amp;state)
        resp.Diagnostics.Append(diags...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        // Get plan Data
        <span class="cov8" title="1">var plan models.ConfigurationRemediation
        diags = req.Plan.Get(ctx, &amp;plan)
        resp.Diagnostics.Append(diags...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">if plan.RunLater.ValueBool() &amp;&amp; plan.Cron.ValueString() == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        clients.ErrBaseLineUpdateRemediation,
                        clients.ErrCronRequired,
                )
                return
        }</span>

        //Create Session and differ the remove session
        <span class="cov8" title="1">omeClient, err := clients.NewClient(*r.p.clientOpt)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        clients.ErrCreateClient,
                        err.Error(),
                )
                return
        }</span>

        <span class="cov8" title="1">_, err = omeClient.CreateSession()
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        clients.ErrCreateSession,
                        err.Error(),
                )
                return
        }</span>
        <span class="cov8" title="1">defer omeClient.RemoveSession()

        tflog.Trace(ctx, "resource_configuration_compliance: update checking if baseline name or id is changed")
        if (plan.BaselineID.ValueInt64() != 0 &amp;&amp; plan.BaselineID.ValueInt64() != state.BaselineID.ValueInt64()) || (plan.BaselineName.ValueString() != "" &amp;&amp; plan.BaselineName.ValueString() != state.BaselineName.ValueString()) </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        clients.ErrBaseLineUpdateRemediation,
                        clients.ErrBaseLineModified,
                )
                return
        }</span>

        <span class="cov8" title="1">tflog.Trace(ctx, "resource_configuration_compliance: update checking for valid baseline")
        baseline, err := checkValidBaseline(omeClient, plan.BaselineName.ValueString(), plan.BaselineID.ValueInt64(), true)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        clients.ErrGnrBaseLineCreateRemediation,
                        err.Error(),
                )
                return
        }</span>

        <span class="cov8" title="1">tflog.Trace(ctx, "resource_configuration_compliance: update checking for terget devices")

        var targetDevices []string
        for _, td := range plan.TargetDevices </span><span class="cov8" title="1">{
                targetDevices = append(targetDevices, td.DeviceServiceTag.ValueString())
        }</span>

        <span class="cov8" title="1">targetDeviceIDs, err := checkValidDevices(omeClient, targetDevices, baseline)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        clients.ErrGnrBaseLineCreateRemediation,
                        err.Error(),
                )
                return
        }</span>

        <span class="cov8" title="1">tflog.Trace(ctx, "resource_configuration_compliance: target devices are valid")
        crp := getRemediationPayload(baseline.ID, targetDeviceIDs, plan.RunLater.ValueBool(), plan.Cron.ValueString())

        tflog.Trace(ctx, "resource_configuration_compliance: update remidiation started", map[string]interface{}{
                "payload": crp,
        })
        jobID, err := omeClient.RemediateBaseLineDevices(crp)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        clients.ErrBaseLineUpdateRemediation,
                        err.Error(),
                )
        }</span>

        <span class="cov8" title="1">tflog.Trace(ctx, "resource_configuration_compliance: update remidiation job created", map[string]interface{}{
                "jobID": jobID,
        })
        if jobID != 0 &amp;&amp; !plan.RunLater.ValueBool() </span><span class="cov8" title="1">{
                isSuccess, err := omeClient.TrackJob(jobID, plan.JobRetryCount.ValueInt64(), plan.SleepInterval.ValueInt64())
                if !isSuccess </span><span class="cov0" title="0">{
                        tflog.Trace(ctx, "resource_configuration_compliance: update remidiation job failed", map[string]interface{}{
                                "err": err,
                        })
                        resp.Diagnostics.AddError(
                                clients.ErrBaseLineUpdateRemediation,
                                err,
                        )
                }</span>
        }

        <span class="cov8" title="1">tflog.Trace(ctx, "resource_configuration_compliance: update remidiation state updating")
        state = plan
        state.BaselineID = types.Int64Value(baseline.ID)
        state.BaselineName = types.StringValue(baseline.Name)
        state.ID = types.StringValue(fmt.Sprintf("%d", baseline.ID))

        //Save into State
        diags = resp.State.Set(ctx, &amp;state)
        resp.Diagnostics.Append(diags...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">tflog.Trace(ctx, "resource_configuration_compliance: update finished")</span>
}

// Delete resource
func (r resourceConfigurationCompliance) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) <span class="cov8" title="1">{
        resp.State.RemoveResource(ctx)
}</span>

// Import resource
func (r resourceConfigurationCompliance) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) <span class="cov0" title="0">{
        // Save the import identifier in the id attribute
        var state models.ConfigurationRemediation
        _ = req.ID

        omeClient, err := clients.NewClient(*r.p.clientOpt)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        clients.ErrCreateClient,
                        err.Error(),
                )
                return
        }</span>

        <span class="cov0" title="0">_, err = omeClient.CreateSession()
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        clients.ErrCreateSession,
                        err.Error(),
                )
                return
        }</span>

        <span class="cov0" title="0">defer omeClient.RemoveSession()

        diags := resp.State.Set(ctx, &amp;state)
        resp.Diagnostics.Append(diags...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>
}

// validate the Devices against the baseline
// validate the baseline
// non compliance devices is handled by remediation API
func checkValidDevices(omeClient *clients.Client, targetDevices []string, baseline models.OmeBaseline) ([]int64, error) <span class="cov8" title="1">{

        var baselineDevices []int64
        var targetDeviceIDs []int64
        deviceIDServiceTagsMap := map[int64]string{}

        for _, bt := range baseline.BaselineTargets </span><span class="cov8" title="1">{
                baselineDevices = append(baselineDevices, bt.ID)
        }</span>

        <span class="cov8" title="1">for _, st := range targetDevices </span><span class="cov8" title="1">{
                device, err := omeClient.GetDevice(st, 0)
                if err != nil </span><span class="cov0" title="0">{
                        return []int64{}, err
                }</span>
                <span class="cov8" title="1">targetDeviceIDs = append(targetDeviceIDs, device.ID)
                deviceIDServiceTagsMap[device.ID] = device.DeviceServiceTag</span>
        }

        <span class="cov8" title="1">diffDeviceIDs := clients.CompareInt64(targetDeviceIDs, baselineDevices)
        diffDeviceServiceTags := []string{}
        for _, diffDeviceID := range diffDeviceIDs </span><span class="cov8" title="1">{
                diffDeviceServiceTags = append(diffDeviceServiceTags, deviceIDServiceTagsMap[diffDeviceID])
        }</span>
        <span class="cov8" title="1">if len(diffDeviceIDs) != 0 </span><span class="cov8" title="1">{
                return []int64{}, fmt.Errorf(clients.ErrBaseLineInvalidDevices, diffDeviceServiceTags)
        }</span>

        <span class="cov8" title="1">return targetDeviceIDs, nil</span>
}

func checkValidBaseline(omeClient *clients.Client, baselineName string, baseLineID int64, checkreportStatus bool) (models.OmeBaseline, error) <span class="cov8" title="1">{
        var baseline models.OmeBaseline
        var err error
        if baseLineID != 0 &amp;&amp; baselineName != "" </span><span class="cov8" title="1">{
                return models.OmeBaseline{}, fmt.Errorf(clients.ErrBaseLineInvalid)
        }</span>
        <span class="cov8" title="1">if baseLineID == 0 &amp;&amp; baselineName == "" </span><span class="cov8" title="1">{
                return models.OmeBaseline{}, fmt.Errorf(clients.ErrBaseLineInvalid)
        }</span>
        <span class="cov8" title="1">if baseLineID != 0 </span><span class="cov8" title="1">{
                baseline, err = omeClient.GetBaselineByID(baseLineID)
        }</span> else<span class="cov8" title="1"> {
                baseline, err = omeClient.GetBaselineByName(baselineName)
        }</span>
        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                return models.OmeBaseline{}, err
        }</span>

        <span class="cov8" title="1">if checkreportStatus </span><span class="cov8" title="1">{
                if strings.ToUpper(baseline.ConfigComplianceSummary.ComplianceStatus) == NotInventoried </span><span class="cov0" title="0">{
                        return models.OmeBaseline{}, fmt.Errorf(clients.ErrBaseLineReportInProgress)
                }</span>
        }
        <span class="cov8" title="1">return baseline, nil</span>
}

func checkReportsStatus(omeClient *clients.Client, baselineID int64) error <span class="cov8" title="1">{
        var baseline models.OmeBaseline
        var err error
        var complianceStatus string
        tries := 1
        baseline, err = omeClient.GetBaselineByID(baselineID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">complianceStatus = baseline.ConfigComplianceSummary.ComplianceStatus
        for strings.ToUpper(complianceStatus) == NotInventoried &amp;&amp; NoOfTriesToGetBaselineStatus != tries </span><span class="cov8" title="1">{
                tries++
                time.Sleep(10 * time.Second) // sleep for 10 secs
                baseline, err = omeClient.GetBaselineByID(baselineID)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">complianceStatus = baseline.ConfigComplianceSummary.ComplianceStatus</span>
        }
        <span class="cov8" title="1">if strings.ToUpper(baseline.ConfigComplianceSummary.ComplianceStatus) == NotInventoried </span><span class="cov0" title="0">{
                return fmt.Errorf(clients.ErrBaseLineReportInProgress)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func getRemediationPayload(baselineID int64, targetDeviceIDs []int64, runLater bool, cron string) models.ConfigurationRemediationPayload <span class="cov8" title="1">{
        crp := models.ConfigurationRemediationPayload{
                ID:        baselineID,
                DeviceIDS: targetDeviceIDs,
                Schedule: models.OMESchedule{
                        RunNow:   true,
                        RunLater: false,
                },
        }
        if runLater </span><span class="cov0" title="0">{
                crp.Schedule.RunNow = false
                crp.Schedule.RunLater = true
                crp.Schedule.Cron = cron
                crp.Schedule.StartTime = ""
                crp.Schedule.EndTime = ""
        }</span>
        <span class="cov8" title="1">return crp</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package ome

import (
        "context"
        "fmt"
        "reflect"
        "strconv"
        "terraform-provider-ome/clients"
        "terraform-provider-ome/models"

        "github.com/hashicorp/terraform-plugin-framework/attr"
        "github.com/hashicorp/terraform-plugin-framework/diag"
        "github.com/hashicorp/terraform-plugin-framework/resource"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema/int64planmodifier"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
        "github.com/hashicorp/terraform-plugin-framework/types"
        "github.com/hashicorp/terraform-plugin-framework/types/basetypes"
        "github.com/hashicorp/terraform-plugin-log/tflog"
)

// Ensure the implementation satisfies the expected interfaces.
var (
        _ resource.Resource                = &amp;resourceDeployment{}
        _ resource.ResourceWithConfigure   = &amp;resourceDeployment{}
        _ resource.ResourceWithImportState = &amp;resourceDeployment{}
)

// NewDeploymentResource is a new resource for deployment
func NewDeploymentResource() resource.Resource <span class="cov8" title="1">{
        return &amp;resourceDeployment{}
}</span>

type resourceDeployment struct {
        p *omeProvider
}

// Configure implements resource.ResourceWithConfigure
func (r *resourceDeployment) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) <span class="cov8" title="1">{
        if req.ProviderData == nil </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">r.p = req.ProviderData.(*omeProvider)</span>
}

// Metadata implements resource.Resource
func (resourceDeployment) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) <span class="cov8" title="1">{
        resp.TypeName = req.ProviderTypeName + "deployment"
}</span>

// Template Deployment Resource schema
func (r resourceDeployment) Schema(_ context.Context, _ resource.SchemaRequest, resp *resource.SchemaResponse) <span class="cov8" title="1">{
        resp.Schema = schema.Schema{
                MarkdownDescription: "Resource for managing template deployment on OpenManage Enterprise. Updates are supported for the following parameters: `device_ids`, `device_servicetags`, `boot_to_network_iso`, `forced_shutdown`, `options_time_to_wait_before_shutdown`, `power_state_off`, `options_precheck_only`, `options_strict_checking_vlan`, `options_continue_on_warning`, `run_later`, `cron`, `device_attributes`, `job_retry_count`, `sleep_interval`.",
                Version:             1,
                Attributes: map[string]schema.Attribute{
                        "id": schema.StringAttribute{
                                MarkdownDescription: "ID of the deploy resource.",
                                Description:         "ID of the deploy resource.",
                                Computed:            true,
                        },
                        "template_id": schema.Int64Attribute{
                                MarkdownDescription: "ID of the existing template.",
                                Description:         "ID of the existing template.",
                                Computed:            true,
                                Optional:            true,
                                PlanModifiers: []planmodifier.Int64{
                                        int64planmodifier.UseStateForUnknown(),
                                },
                        },
                        "template_name": schema.StringAttribute{
                                MarkdownDescription: "Name of the existing template.",
                                Description:         "Name of the existing template.",
                                Optional:            true,
                                Computed:            true,
                                PlanModifiers: []planmodifier.String{
                                        stringplanmodifier.UseStateForUnknown(),
                                },
                        },
                        "device_ids": schema.SetAttribute{
                                MarkdownDescription: "List of the device id(s).",
                                Description:         "List of the device id(s).",
                                ElementType:         types.Int64Type,
                                Optional:            true,
                        },
                        "device_servicetags": schema.SetAttribute{
                                MarkdownDescription: "List of the device servicetags.",
                                Description:         "List of the device servicetags.",
                                ElementType:         types.StringType,
                                Optional:            true,
                        },
                        "boot_to_network_iso": schema.ObjectAttribute{
                                MarkdownDescription: "Boot To Network ISO deployment details.",
                                Description:         "Boot To Network ISO deployment details.",
                                Optional:            true,
                                AttributeTypes: map[string]attr.Type{
                                        "boot_to_network": types.BoolType,
                                        "share_type":      types.StringType,
                                        "iso_timeout":     types.Int64Type,
                                        "iso_path":        types.StringType,
                                        "share_detail": types.ObjectType{
                                                AttrTypes: map[string]attr.Type{
                                                        "ip_address": types.StringType,
                                                        "share_name": types.StringType,
                                                        "work_group": types.StringType,
                                                        "user":       types.StringType,
                                                        "password":   types.StringType,
                                                }},
                                },
                        },
                        "forced_shutdown": schema.BoolAttribute{
                                MarkdownDescription: "Force shutdown after deployment.",
                                Description:         "Force shutdown after deployment.",
                                Optional:            true,
                        },
                        "options_time_to_wait_before_shutdown": schema.Int64Attribute{
                                MarkdownDescription: "Option to specify the time to wait before shutdown in seconds. Default and minimum value is 300 and maximum is 3600 seconds respectively.",
                                Description:         "Option to specify the time to wait before shutdown in seconds. Default and minimum value is 300 and maximum is 3600 seconds respectively.",
                                Optional:            true,
                                Computed:            true,
                                PlanModifiers: []planmodifier.Int64{
                                        Int64DefaultValue(types.Int64Value(300)),
                                },
                        },
                        "power_state_off": schema.BoolAttribute{
                                MarkdownDescription: "End power state of a target devices. Default power state is ON. Make it true to switch it to OFF state.",
                                Description:         "End power state of a target devices. Default power state is ON. Make it true to switch it to OFF state.",
                                Optional:            true,
                        },
                        "options_precheck_only": schema.BoolAttribute{
                                MarkdownDescription: "Option to precheck",
                                Description:         "Option to precheck",
                                Optional:            true,
                        },
                        "options_strict_checking_vlan": schema.BoolAttribute{
                                MarkdownDescription: "Checks the strict association of vlan.",
                                Description:         "Checks the strict association of vlan.",
                                Optional:            true,
                        },
                        "options_continue_on_warning": schema.BoolAttribute{
                                MarkdownDescription: "Continue to run the job on warnings.",
                                Description:         "Continue to run the job on warnings.",
                                Optional:            true,
                        },
                        "run_later": schema.BoolAttribute{
                                MarkdownDescription: "Provides options to schedule the deployment task immediately, or at a specified time.",
                                Description:         "Provides options to schedule the deployment task immediately, or at a specified time.",
                                Optional:            true,
                        },
                        "cron": schema.StringAttribute{
                                MarkdownDescription: "Cron to schedule the deployment task. Cron expression should be of future datetime.",
                                Description:         "Cron to schedule the deployment task. Cron expression should be of future datetime.",
                                Optional:            true,
                        },
                        "device_attributes": schema.ListAttribute{
                                MarkdownDescription: "List of template attributes associated with the target devices for deploymnent.",
                                Description:         "List of template attributes associated with the target devices for deploymnent.",
                                Optional:            true,
                                ElementType: types.ObjectType{
                                        AttrTypes: map[string]attr.Type{
                                                "device_servicetags": types.SetType{
                                                        ElemType: types.StringType,
                                                },
                                                "attributes": types.ListType{
                                                        ElemType: types.ObjectType{
                                                                AttrTypes: map[string]attr.Type{
                                                                        "attribute_id": types.Int64Type,
                                                                        "display_name": types.StringType,
                                                                        "value":        types.StringType,
                                                                        "is_ignored":   types.BoolType,
                                                                },
                                                        },
                                                },
                                        },
                                },
                        },
                        "job_retry_count": schema.Int64Attribute{
                                MarkdownDescription: "Number of times the job has to be polled to get the final status of the resource.",
                                Description:         "Number of times the job has to be polled to get the final status of the resource.",
                                Optional:            true,
                                Computed:            true,
                                PlanModifiers: []planmodifier.Int64{
                                        Int64DefaultValue(types.Int64Value(20)),
                                },
                        },
                        "sleep_interval": schema.Int64Attribute{
                                MarkdownDescription: "Sleep time interval for job polling in seconds.",
                                Description:         "Sleep time interval for job polling in seconds.",
                                Optional:            true,
                                Computed:            true,
                                PlanModifiers: []planmodifier.Int64{
                                        Int64DefaultValue(types.Int64Value(60)),
                                },
                        },
                },
        }
}</span>

// Create a new resource
func (r resourceDeployment) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) <span class="cov8" title="1">{
        tflog.Trace(ctx, "resource_deploy create : Started")
        //Get Plan Data
        var plan models.TemplateDeployment
        diags := req.Plan.Get(ctx, &amp;plan)
        resp.Diagnostics.Append(diags...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">templateDeploymentState := models.TemplateDeployment{}

        //Create Session and differ the remove session
        omeClient, err := clients.NewClient(*r.p.clientOpt)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        clients.ErrCreateClient,
                        err.Error(),
                )
                return
        }</span>

        <span class="cov8" title="1">_, err = omeClient.CreateSession()
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        clients.ErrCreateSession,
                        err.Error(),
                )
                return
        }</span>
        <span class="cov8" title="1">defer omeClient.RemoveSession()

        tflog.Trace(ctx, "resource_deploy create: session created")

        omeTemplate, err := omeClient.GetTemplateByIDOrName(plan.TemplateID.ValueInt64(), plan.TemplateName.ValueString())
        if err != nil </span><span class="cov8" title="1">{
                resp.Diagnostics.AddError(
                        clients.ErrInvalidTemplate,
                        err.Error(),
                )
                return
        }</span>

        <span class="cov8" title="1">tflog.Debug(ctx, "resource_deploy create: ome Template", map[string]interface{}{
                "id":   omeTemplate.ID,
                "name": omeTemplate.Name,
        })

        var serviceTags []string
        var devIDs []int64

        diags = plan.DeviceServicetags.ElementsAs(ctx, &amp;serviceTags, true)
        if diags.HasError() </span><span class="cov0" title="0">{
                resp.Diagnostics.Append(diags...)
                return
        }</span>

        <span class="cov8" title="1">diags = plan.DeviceIDs.ElementsAs(ctx, &amp;devIDs, true)
        if diags.HasError() </span><span class="cov0" title="0">{
                resp.Diagnostics.Append(diags...)
                return
        }</span>

        <span class="cov8" title="1">usedDeviceInput, err := clients.DeviceMutuallyExclusive(serviceTags, devIDs)
        if err != nil </span><span class="cov8" title="1">{
                resp.Diagnostics.AddError(
                        clients.ErrTemplateDeploymentCreate, err.Error(),
                )
                return
        }</span>

        <span class="cov8" title="1">devices, err := omeClient.GetDevices(serviceTags, devIDs, []string{})
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        clients.ErrTemplateDeploymentCreate, err.Error(),
                )
                return
        }</span>

        <span class="cov8" title="1">_, deviceIDs, _ := omeClient.GetUniqueDevicesIdsAndServiceTags(devices)

        options := getOptions(plan)

        deploymentRequest := models.OMETemplateDeployRequest{
                ID:        omeTemplate.ID,
                TargetIDS: deviceIDs,
                Options:   options,
        }

        //Boot to Network ISO starts
        if !plan.BootToNetworkISO.IsNull() </span><span class="cov8" title="1">{
                bootToNetworkISOModel, diags, err := getBootToNetworkISO(ctx, plan)
                if err != nil </span><span class="cov0" title="0">{
                        resp.Diagnostics.Append(diags...)
                        resp.Diagnostics.AddWarning(
                                clients.ErrUnableToParseData,
                                err.Error(),
                        )
                }</span>
                <span class="cov8" title="1">deploymentRequest.NetworkBootISOModel = bootToNetworkISOModel</span>
        }
        //Boot to Network ISO Ends
        // Schedule Starts
        <span class="cov8" title="1">if plan.RunLater.ValueBool() </span><span class="cov8" title="1">{
                deploymentRequest.Schedule = getSchedule(plan)
        }</span>
        //Schedule ends
        // Device Attrs
        <span class="cov8" title="1">if len(plan.DeviceAttributes.Elements()) &gt; 0 </span><span class="cov8" title="1">{
                deploymentRequest.Attributes = getDeviceAttributes(ctx, devices, plan)
        }</span>

        <span class="cov8" title="1">tflog.Trace(ctx, "resource_deploy create: started creating deployment job")

        deploymentJobID, err := omeClient.CreateDeployment(deploymentRequest)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        clients.ErrTemplateDeploymentCreate, err.Error(),
                )
                return
        }</span>

        <span class="cov8" title="1">tflog.Debug(ctx, "resource_deploy create: finished creating deployment job", map[string]interface{}{
                "deploymentJobID": deploymentJobID,
        })

        if !plan.RunLater.ValueBool() </span><span class="cov8" title="1">{
                tflog.Trace(ctx, "resource_deploy create: started job tracking")
                isSuccess, message := omeClient.TrackJob(deploymentJobID, plan.JobRetryCount.ValueInt64(), plan.SleepInterval.ValueInt64())
                if !isSuccess </span><span class="cov8" title="1">{
                        resp.Diagnostics.AddWarning(
                                clients.ErrTemplateDeploymentCreate, message,
                        )
                }</span>
        }

        <span class="cov8" title="1">tflog.Trace(ctx, "resource_deploy create: updating state started")

        _ = updateDeploymentState(&amp;templateDeploymentState, &amp;plan, omeTemplate.ID, omeTemplate.Name, omeClient, usedDeviceInput)

        tflog.Trace(ctx, "resource_deploy create: updating state finished, saving ...")
        // Save into State
        diags = resp.State.Set(ctx, &amp;templateDeploymentState)
        resp.Diagnostics.Append(diags...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">tflog.Trace(ctx, "resource_deploy create: finish")</span>
}

// Read resource information
func (r resourceDeployment) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) <span class="cov8" title="1">{
        //Get State Data
        tflog.Trace(ctx, "resource_deploy read: started")
        var stateTemplateDeployment models.TemplateDeployment
        diags := req.State.Get(ctx, &amp;stateTemplateDeployment)
        resp.Diagnostics.Append(diags...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">templateID := stateTemplateDeployment.TemplateID.ValueInt64()
        templateName := stateTemplateDeployment.TemplateName.ValueString()

        tflog.Debug(ctx, "resource_deploy read: reading a template", map[string]interface{}{
                "id":   templateID,
                "name": templateName,
        })
        var serviceTags []string
        var devIDs []int64

        diags = stateTemplateDeployment.DeviceServicetags.ElementsAs(ctx, &amp;serviceTags, true)
        if diags.HasError() </span><span class="cov0" title="0">{
                resp.Diagnostics.Append(diags...)
                return
        }</span>

        <span class="cov8" title="1">diags = stateTemplateDeployment.DeviceIDs.ElementsAs(ctx, &amp;devIDs, true)
        if diags.HasError() </span><span class="cov0" title="0">{
                resp.Diagnostics.Append(diags...)
                return
        }</span>

        <span class="cov8" title="1">var usedDeviceInput string
        if len(serviceTags) &gt; 0 </span><span class="cov8" title="1">{
                usedDeviceInput = clients.ServiceTags
        }</span> else<span class="cov0" title="0"> if len(devIDs) &gt; 0 </span><span class="cov0" title="0">{
                usedDeviceInput = clients.DeviceIDs
        }</span>

        //Create Session and differ the remove session
        <span class="cov8" title="1">omeClient, err := clients.NewClient(*r.p.clientOpt)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        clients.ErrCreateClient,
                        err.Error(),
                )
                return
        }</span>

        <span class="cov8" title="1">_, err = omeClient.CreateSession()
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        clients.ErrCreateSession,
                        err.Error(),
                )
                return
        }</span>
        <span class="cov8" title="1">defer omeClient.RemoveSession()

        tflog.Trace(ctx, "resource_deploy read: client created started updating state")
        _ = updateDeploymentState(&amp;stateTemplateDeployment, &amp;stateTemplateDeployment, templateID, templateName, omeClient, usedDeviceInput)

        tflog.Trace(ctx, "resource_deploy read: finished reading state")
        //Save into State
        diags = resp.State.Set(ctx, &amp;stateTemplateDeployment)
        resp.Diagnostics.Append(diags...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">tflog.Trace(ctx, "resource_deploy read: finished")</span>
}

// Update resource
func (r resourceDeployment) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) <span class="cov8" title="1">{
        //Get state Data
        tflog.Trace(ctx, "resource_deploy update: started")
        var state models.TemplateDeployment
        diags := req.State.Get(ctx, &amp;state)
        resp.Diagnostics.Append(diags...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        // Get plan Data
        <span class="cov8" title="1">var plan models.TemplateDeployment
        diags = req.Plan.Get(ctx, &amp;plan)
        resp.Diagnostics.Append(diags...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        //Create Session and differ the remove session
        <span class="cov8" title="1">omeClient, err := clients.NewClient(*r.p.clientOpt)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        clients.ErrCreateClient,
                        err.Error(),
                )
                return
        }</span>

        <span class="cov8" title="1">_, err = omeClient.CreateSession()
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        clients.ErrCreateSession,
                        err.Error(),
                )
                return
        }</span>
        <span class="cov8" title="1">defer omeClient.RemoveSession()

        if (plan.TemplateID.ValueInt64() != 0 &amp;&amp; plan.TemplateID.ValueInt64() != state.TemplateID.ValueInt64()) || (plan.TemplateName.ValueString() != "" &amp;&amp; plan.TemplateName.ValueString() != state.TemplateName.ValueString()) </span><span class="cov8" title="1">{
                resp.Diagnostics.AddError(
                        clients.ErrTemplateDeploymentUpdate,
                        clients.ErrTemplateChanges,
                )
                return
        }</span>
        <span class="cov8" title="1">tflog.Debug(ctx, "resource_deploy update: started with template", map[string]interface{}{
                "id":   plan.TemplateID.ValueInt64(),
                "name": plan.TemplateName.ValueString(),
        })

        var serviceTags []string
        var devIDs []int64

        diags = plan.DeviceServicetags.ElementsAs(ctx, &amp;serviceTags, true)
        if diags.HasError() </span><span class="cov0" title="0">{
                resp.Diagnostics.Append(diags...)
                return
        }</span>

        <span class="cov8" title="1">diags = plan.DeviceIDs.ElementsAs(ctx, &amp;devIDs, true)
        if diags.HasError() </span><span class="cov0" title="0">{
                resp.Diagnostics.Append(diags...)
                return
        }</span>

        <span class="cov8" title="1">usedDeviceInput, err := clients.DeviceMutuallyExclusive(serviceTags, devIDs)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        clients.ErrTemplateDeploymentUpdate, err.Error(),
                )
                return
        }</span>

        <span class="cov8" title="1">planDevices, err := omeClient.GetDevices(serviceTags, devIDs, []string{})
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        clients.ErrTemplateDeploymentUpdate, err.Error(),
                )
                return
        }</span>

        <span class="cov8" title="1">_, planDeviceIDs, _ := omeClient.GetUniqueDevicesIdsAndServiceTags(planDevices)
        //get the state devicds's

        var stateServiceTags []string
        var stateDevIDs []int64

        diags = state.DeviceServicetags.ElementsAs(ctx, &amp;stateServiceTags, true)
        if diags.HasError() </span><span class="cov0" title="0">{
                resp.Diagnostics.Append(diags...)
                return
        }</span>

        <span class="cov8" title="1">diags = state.DeviceIDs.ElementsAs(ctx, &amp;stateDevIDs, true)
        if diags.HasError() </span><span class="cov0" title="0">{
                resp.Diagnostics.Append(diags...)
                return
        }</span>

        <span class="cov8" title="1">serverProfiles, err := omeClient.GetServerProfileInfoByTemplateName(state.TemplateName.ValueString())
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        clients.ErrTemplateDeploymentUpdate, err.Error(),
                )
                return
        }</span>

        <span class="cov8" title="1">var stateDeviceIDs []int64

        for _, serverProfile := range serverProfiles.Value </span><span class="cov8" title="1">{
                stateDeviceIDs = append(stateDeviceIDs, serverProfile.TargetID)
        }</span>

        <span class="cov8" title="1">newDeployDevIDs := compare(planDeviceIDs, stateDeviceIDs)

        //remove
        removeDeployDevIDs := compare(stateDeviceIDs, planDeviceIDs)

        tflog.Debug(ctx, "resource_deploy update: Target ids", map[string]interface{}{
                "newTargets":    newDeployDevIDs,
                "removeTargets": removeDeployDevIDs,
        })

        options := getOptions(plan)

        deploymentRequest := models.OMETemplateDeployRequest{
                ID:        state.TemplateID.ValueInt64(),
                TargetIDS: newDeployDevIDs,
                Options:   options,
        }

        //Boot to Network ISO starts
        if !plan.BootToNetworkISO.IsNull() </span><span class="cov8" title="1">{
                bootToNetworkISOModel, diags, err := getBootToNetworkISO(ctx, plan)
                if err != nil </span><span class="cov0" title="0">{
                        resp.Diagnostics.Append(diags...)
                        resp.Diagnostics.AddWarning(
                                clients.ErrUnableToParseData,
                                err.Error(),
                        )
                }</span>
                <span class="cov8" title="1">deploymentRequest.NetworkBootISOModel = bootToNetworkISOModel</span>
        }
        //Boot to Network ISO Ends
        // Schedule Starts
        <span class="cov8" title="1">if plan.RunLater.ValueBool() </span><span class="cov8" title="1">{
                deploymentRequest.Schedule = getSchedule(plan)
        }</span>
        //Schedule ends
        // Device Attrs
        <span class="cov8" title="1">if len(plan.DeviceAttributes.Elements()) &gt; 0 </span><span class="cov8" title="1">{
                deploymentRequest.Attributes = getDeviceAttributes(ctx, planDevices, plan)
        }</span>

        <span class="cov8" title="1">if len(newDeployDevIDs) &gt; 0 </span><span class="cov8" title="1">{
                tflog.Trace(ctx, "resource_deploy update: started deployment")
                deploymentJobID, err := omeClient.CreateDeployment(deploymentRequest)
                if err != nil </span><span class="cov0" title="0">{
                        resp.Diagnostics.AddError(
                                clients.ErrTemplateDeploymentUpdate, err.Error(),
                        )
                        return
                }</span>

                <span class="cov8" title="1">if !plan.RunLater.ValueBool() </span><span class="cov8" title="1">{
                        tflog.Trace(ctx, "resource_deploy update: started job tracking")
                        isSuccess, message := omeClient.TrackJob(deploymentJobID, plan.JobRetryCount.ValueInt64(), plan.SleepInterval.ValueInt64())
                        if !isSuccess </span><span class="cov8" title="1">{
                                resp.Diagnostics.AddWarning(
                                        "unable to complete the deployment for the template: ", message,
                                )
                        }</span>
                }
        }

        <span class="cov8" title="1">if len(removeDeployDevIDs) &gt; 0 </span><span class="cov8" title="1">{
                profileArr := make([]int64, len(removeDeployDevIDs))
                for i, removeDevID := range removeDeployDevIDs </span><span class="cov8" title="1">{
                        for _, serverProfile := range serverProfiles.Value </span><span class="cov8" title="1">{
                                if serverProfile.TargetID == removeDevID </span><span class="cov8" title="1">{
                                        profileArr[i] = serverProfile.ID
                                }</span>
                        }
                }
                <span class="cov8" title="1">tflog.Debug(ctx, "resource_deploy update: deleting server profiles", map[string]interface{}{
                        "profileIds": profileArr,
                })
                err = deleteProfiles(ctx, omeClient, profileArr)
                if err != nil </span><span class="cov0" title="0">{
                        resp.Diagnostics.AddError(
                                clients.ErrTemplateDeploymentUpdate,
                                err.Error(),
                        )
                        return
                }</span>
        }

        <span class="cov8" title="1">tflog.Trace(ctx, "resource_deploy update: started state update")

        _ = updateDeploymentState(&amp;state, &amp;plan, state.TemplateID.ValueInt64(), state.TemplateName.ValueString(), omeClient, usedDeviceInput)

        tflog.Trace(ctx, "resource_deploy update: finished state update")
        //Save into State
        diags = resp.State.Set(ctx, &amp;state)
        resp.Diagnostics.Append(diags...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">tflog.Trace(ctx, "resource_deploy update: finished")</span>
}

// Delete resource
func (r resourceDeployment) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) <span class="cov8" title="1">{
        tflog.Trace(ctx, "resource_deploy delete: started")
        // Get State Data
        var statetemplateDeployment models.TemplateDeployment
        diags := req.State.Get(ctx, &amp;statetemplateDeployment)
        resp.Diagnostics.Append(diags...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        //Create Session and differ the remove session
        <span class="cov8" title="1">omeClient, err := clients.NewClient(*r.p.clientOpt)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        clients.ErrCreateClient,
                        err.Error(),
                )
                return
        }</span>

        <span class="cov8" title="1">_, err = omeClient.CreateSession()
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        clients.ErrCreateSession,
                        err.Error(),
                )
                return
        }</span>
        <span class="cov8" title="1">defer omeClient.RemoveSession()

        tflog.Debug(ctx, "resource_deploy delete: started with template", map[string]interface{}{
                "id":   statetemplateDeployment.TemplateID.ValueInt64(),
                "name": statetemplateDeployment.TemplateName.ValueString(),
        })

        serverProfiles, err := omeClient.GetServerProfileInfoByTemplateName(statetemplateDeployment.TemplateName.ValueString())
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        clients.ErrTemplateDeploymentDelete, err.Error(),
                )
                return
        }</span>

        <span class="cov8" title="1">profileArr := make([]int64, len(serverProfiles.Value))

        for i, serverProfile := range serverProfiles.Value </span><span class="cov8" title="1">{
                profileArr[i] = serverProfile.ID
        }</span>

        <span class="cov8" title="1">tflog.Debug(ctx, "resource_deploy delete: deleting server profiles", map[string]interface{}{
                "profileIds": profileArr,
        })

        err = deleteProfiles(ctx, omeClient, profileArr)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        clients.ErrTemplateDeploymentDelete,
                        err.Error(),
                )
                return
        }</span>
        <span class="cov8" title="1">resp.State.RemoveResource(ctx)
        tflog.Trace(ctx, "resource_deploy delete: finished")</span>
}

func deleteProfiles(ctx context.Context, omeClient *clients.Client, profileArr []int64) error <span class="cov8" title="1">{
        pdr := models.ProfileDeleteRequest{
                ProfileIds: profileArr,
        }
        err := omeClient.DeleteDeployment(pdr)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// Import resource
func (r resourceDeployment) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) <span class="cov8" title="1">{
        tflog.Trace(ctx, "resource_deploy import: started")
        // Save the import identifier in the id attribute
        var stateTemplateDeployment models.TemplateDeployment
        templateName := req.ID
        omeClient, err := clients.NewClient(*r.p.clientOpt)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        clients.ErrCreateClient,
                        err.Error(),
                )
                return
        }</span>

        <span class="cov8" title="1">_, err = omeClient.CreateSession()
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        clients.ErrCreateSession,
                        err.Error(),
                )
                return
        }</span>

        <span class="cov8" title="1">omeTemplate, err := omeClient.GetTemplateByName(templateName)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(clients.ErrImportDeployment, err.Error())
                return
        }</span>
        <span class="cov8" title="1">templateID := omeTemplate.ID

        //Create Session and differ the remove session
        defer omeClient.RemoveSession()

        profileDevSTVals := []attr.Value{}
        serverProfiles, err := omeClient.GetServerProfileInfoByTemplateName(templateName)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(clients.ErrImportDeployment, err.Error())
                return
        }</span>

        <span class="cov8" title="1">if len(serverProfiles.Value) == 0 </span><span class="cov8" title="1">{
                resp.Diagnostics.AddError(clients.ErrImportDeployment, fmt.Sprintf(clients.ErrImportNoProfiles, templateName))
                return
        }</span>

        <span class="cov8" title="1">for _, serverProfile := range serverProfiles.Value </span><span class="cov8" title="1">{
                device, _ := omeClient.GetDevice("", serverProfile.TargetID)
                deviceSTVal := types.StringValue(device.DeviceServiceTag)
                profileDevSTVals = append(profileDevSTVals, deviceSTVal)
        }</span>
        <span class="cov8" title="1">stateTemplateDeployment.ID = types.StringValue(strconv.FormatInt(templateID, 10))
        stateTemplateDeployment.TemplateID = types.Int64Value(templateID)
        stateTemplateDeployment.TemplateName = types.StringValue(templateName)
        devSTsTfsdk, _ := types.SetValue(
                types.StringType,
                profileDevSTVals,
        )
        if !devSTsTfsdk.IsUnknown() </span><span class="cov8" title="1">{
                stateTemplateDeployment.DeviceServicetags = devSTsTfsdk
        }</span>
        <span class="cov8" title="1">devIDsTfsdk, _ := types.SetValue(types.Int64Type, []attr.Value{})
        if !devIDsTfsdk.IsUnknown() </span><span class="cov8" title="1">{
                stateTemplateDeployment.DeviceIDs = devIDsTfsdk
        }</span>
        // set empty device attributes
        <span class="cov8" title="1">attributesObjects := []attr.Value{}
        attributesObject, _ := types.ObjectValue(
                map[string]attr.Type{
                        "attribute_id": types.Int64Type,
                        "display_name": types.StringType,
                        "value":        types.StringType,
                        "is_ignored":   types.BoolType,
                },
                map[string]attr.Value{
                        "attribute_id": types.Int64Value(0),
                        "display_name": types.StringValue(""),
                        "value":        types.StringValue(""),
                        "is_ignored":   types.BoolValue(false),
                },
        )
        attributesObjects = append(attributesObjects, attributesObject)

        attributesTfsdk, _ := types.ListValue(
                types.ObjectType{
                        AttrTypes: map[string]attr.Type{
                                "attribute_id": types.Int64Type,
                                "display_name": types.StringType,
                                "value":        types.StringType,
                                "is_ignored":   types.BoolType,
                        },
                },
                attributesObjects,
        )

        deviceAttributeObjects := []attr.Value{}
        deviceAttributeObject, _ := types.ObjectValue(
                map[string]attr.Type{
                        "device_servicetags": types.SetType{
                                ElemType: types.StringType,
                        },
                        "attributes": types.ListType{
                                ElemType: types.ObjectType{
                                        AttrTypes: map[string]attr.Type{
                                                "attribute_id": types.Int64Type,
                                                "display_name": types.StringType,
                                                "value":        types.StringType,
                                                "is_ignored":   types.BoolType,
                                        },
                                },
                        },
                },
                map[string]attr.Value{
                        "device_servicetags": devSTsTfsdk,
                        "attributes":         attributesTfsdk,
                },
        )

        deviceAttributeObjects = append(deviceAttributeObjects, deviceAttributeObject)

        deviceAttributeTfsdk, _ := types.ListValue(
                types.ObjectType{
                        AttrTypes: map[string]attr.Type{
                                "device_servicetags": types.SetType{
                                        ElemType: types.StringType,
                                },
                                "attributes": types.ListType{
                                        ElemType: types.ObjectType{
                                                AttrTypes: map[string]attr.Type{
                                                        "attribute_id": types.Int64Type,
                                                        "display_name": types.StringType,
                                                        "value":        types.StringType,
                                                        "is_ignored":   types.BoolType,
                                                },
                                        },
                                },
                        },
                },
                deviceAttributeObjects,
        )

        if !deviceAttributeTfsdk.IsUnknown() </span><span class="cov8" title="1">{
                stateTemplateDeployment.DeviceAttributes = deviceAttributeTfsdk
        }</span>
        <span class="cov8" title="1">shareDetailsTfsdk, _ := types.ObjectValue(
                map[string]attr.Type{
                        "ip_address": types.StringType,
                        "share_name": types.StringType,
                        "work_group": types.StringType,
                        "user":       types.StringType,
                        "password":   types.StringType,
                },
                map[string]attr.Value{
                        "ip_address": types.StringValue(""),
                        "share_name": types.StringValue(""),
                        "work_group": types.StringValue(""),
                        "user":       types.StringValue(""),
                        "password":   types.StringValue(""),
                },
        )

        bootToNetworkISOTfsdk, _ := types.ObjectValue(
                map[string]attr.Type{
                        "boot_to_network": types.BoolType,
                        "share_type":      types.StringType,
                        "iso_timeout":     types.Int64Type,
                        "iso_path":        types.StringType,
                        "share_detail": types.ObjectType{
                                AttrTypes: map[string]attr.Type{
                                        "ip_address": types.StringType,
                                        "share_name": types.StringType,
                                        "work_group": types.StringType,
                                        "user":       types.StringType,
                                        "password":   types.StringType,
                                },
                        },
                },
                map[string]attr.Value{
                        "boot_to_network": types.BoolValue(false),
                        "share_type":      types.StringValue(""),
                        "iso_timeout":     types.Int64Value(0),
                        "iso_path":        types.StringValue(""),
                        "share_detail":    shareDetailsTfsdk,
                },
        )

        if !bootToNetworkISOTfsdk.IsUnknown() </span><span class="cov8" title="1">{
                stateTemplateDeployment.BootToNetworkISO = bootToNetworkISOTfsdk
        }</span>
        //Save into State
        <span class="cov8" title="1">diags := resp.State.Set(ctx, &amp;stateTemplateDeployment)
        resp.Diagnostics.Append(diags...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">tflog.Trace(ctx, "resource_deploy import: finished")</span>
}

func updateDeploymentState(stateTemplateDeployment, planTemplateDeployment *models.TemplateDeployment, templateID int64, templateName string, omeClient *clients.Client, usedDeviceInput string) error <span class="cov8" title="1">{
        stateTemplateDeployment.ID = types.StringValue(strconv.FormatInt(templateID, 10))
        stateTemplateDeployment.TemplateID = types.Int64Value(templateID)
        stateTemplateDeployment.TemplateName = types.StringValue(templateName)
        if !planTemplateDeployment.JobRetryCount.IsUnknown() </span><span class="cov8" title="1">{
                stateTemplateDeployment.JobRetryCount = planTemplateDeployment.JobRetryCount
        }</span>
        <span class="cov8" title="1">if !planTemplateDeployment.SleepInterval.IsUnknown() </span><span class="cov8" title="1">{
                stateTemplateDeployment.SleepInterval = planTemplateDeployment.SleepInterval
        }</span>
        <span class="cov8" title="1">devIDList := planTemplateDeployment.DeviceIDs.Elements()
        devSTList := planTemplateDeployment.DeviceServicetags.Elements()
        profileDevSTVals := []attr.Value{}
        profileDevIDVals := []attr.Value{}
        serverProfiles, err := omeClient.GetServerProfileInfoByTemplateName(templateName)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">for _, serverProfile := range serverProfiles.Value </span><span class="cov8" title="1">{
                device, _ := omeClient.GetDevice("", serverProfile.TargetID)
                deviceSTVal := types.StringValue(device.DeviceServiceTag)
                profileDevSTVals = append(profileDevSTVals, deviceSTVal)
                deviceIDVal := types.Int64Value(serverProfile.TargetID)
                profileDevIDVals = append(profileDevIDVals, deviceIDVal)
        }</span>

        <span class="cov8" title="1">filteredDevSTList := []attr.Value{}
        for _, planDevST := range devSTList </span><span class="cov8" title="1">{
                if tfsdkContains(profileDevSTVals, planDevST) </span><span class="cov8" title="1">{
                        filteredDevSTList = append(filteredDevSTList, planDevST)
                }</span>
        }

        <span class="cov8" title="1">filteredDevIDList := []attr.Value{}
        for _, planDevID := range devIDList </span><span class="cov0" title="0">{
                if tfsdkContains(profileDevIDVals, planDevID) </span><span class="cov0" title="0">{
                        filteredDevIDList = append(filteredDevIDList, planDevID)
                }</span>
        }

        <span class="cov8" title="1">for _, profileDevID := range profileDevIDVals </span><span class="cov8" title="1">{
                if !tfsdkContains(devIDList, profileDevID) </span><span class="cov8" title="1">{
                        filteredDevIDList = append(filteredDevIDList, profileDevID)
                }</span>
        }

        <span class="cov8" title="1">for _, profileDevST := range profileDevSTVals </span><span class="cov8" title="1">{
                if !tfsdkContains(devSTList, profileDevST) </span><span class="cov0" title="0">{
                        filteredDevSTList = append(filteredDevSTList, profileDevST)
                }</span>
        }

        <span class="cov8" title="1">switch usedDeviceInput </span>{
        case clients.ServiceTags:<span class="cov8" title="1">
                devSTsTfsdk, _ := types.SetValue(
                        types.StringType,
                        filteredDevSTList,
                )
                stateTemplateDeployment.DeviceServicetags = devSTsTfsdk
                stateTemplateDeployment.DeviceIDs = types.SetNull(types.Int64Type)</span>
                //planTemplateDeployment.DeviceIDs
        case clients.DeviceIDs:<span class="cov0" title="0">
                devIDsTfsdk, _ := types.SetValue(
                        types.Int64Type,
                        filteredDevIDList,
                )
                stateTemplateDeployment.DeviceIDs = devIDsTfsdk
                stateTemplateDeployment.DeviceServicetags = types.SetNull(types.StringType)</span>
        }
        <span class="cov8" title="1">if !planTemplateDeployment.BootToNetworkISO.IsUnknown() </span><span class="cov8" title="1">{
                stateTemplateDeployment.BootToNetworkISO = planTemplateDeployment.BootToNetworkISO
        }</span>
        <span class="cov8" title="1">if !planTemplateDeployment.DeviceAttributes.IsUnknown() </span><span class="cov8" title="1">{
                stateTemplateDeployment.DeviceAttributes = planTemplateDeployment.DeviceAttributes
        }</span>
        <span class="cov8" title="1">if !planTemplateDeployment.OptionsContinueOnWarning.IsUnknown() </span><span class="cov8" title="1">{
                stateTemplateDeployment.OptionsContinueOnWarning = planTemplateDeployment.OptionsContinueOnWarning
        }</span>
        <span class="cov8" title="1">if !planTemplateDeployment.PowerStateOff.IsUnknown() </span><span class="cov8" title="1">{
                stateTemplateDeployment.PowerStateOff = planTemplateDeployment.PowerStateOff
        }</span>
        <span class="cov8" title="1">if !planTemplateDeployment.OptionsPrecheckOnly.IsUnknown() </span><span class="cov8" title="1">{
                stateTemplateDeployment.OptionsPrecheckOnly = planTemplateDeployment.OptionsPrecheckOnly
        }</span>
        <span class="cov8" title="1">if !planTemplateDeployment.ForcedShutdown.IsUnknown() </span><span class="cov8" title="1">{
                stateTemplateDeployment.ForcedShutdown = planTemplateDeployment.ForcedShutdown
        }</span>
        <span class="cov8" title="1">if !planTemplateDeployment.OptionsStrictCheckingVlan.IsUnknown() </span><span class="cov8" title="1">{
                stateTemplateDeployment.OptionsStrictCheckingVlan = planTemplateDeployment.OptionsStrictCheckingVlan
        }</span>
        <span class="cov8" title="1">if !planTemplateDeployment.OptionsTimeToWaitBeforeShutdown.IsUnknown() </span><span class="cov8" title="1">{
                stateTemplateDeployment.OptionsTimeToWaitBeforeShutdown = planTemplateDeployment.OptionsTimeToWaitBeforeShutdown
        }</span>
        <span class="cov8" title="1">if !planTemplateDeployment.RunLater.IsUnknown() </span><span class="cov8" title="1">{
                stateTemplateDeployment.RunLater = planTemplateDeployment.RunLater
        }</span>
        <span class="cov8" title="1">if !planTemplateDeployment.Cron.IsUnknown() </span><span class="cov8" title="1">{
                stateTemplateDeployment.Cron = planTemplateDeployment.Cron
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func compare(comparing, comparedTo []int64) []int64 <span class="cov8" title="1">{
        compareToMap := make(map[int64]int64)
        for _, val := range comparedTo </span><span class="cov8" title="1">{
                compareToMap[val]++
        }</span>

        <span class="cov8" title="1">var devIDs []int64
        for _, val := range comparing </span><span class="cov8" title="1">{
                if compareToMap[val] &gt; 0 </span><span class="cov0" title="0">{
                        compareToMap[val]--
                        continue</span>
                }
                <span class="cov8" title="1">devIDs = append(devIDs, val)</span>
        }
        <span class="cov8" title="1">return devIDs</span>
}

func tfsdkContains(toCheckList []attr.Value, toCheck attr.Value) bool <span class="cov8" title="1">{
        for _, val := range toCheckList </span><span class="cov8" title="1">{
                if reflect.DeepEqual(val, toCheck) </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

func getSchedule(plan models.TemplateDeployment) models.OMESchedule <span class="cov8" title="1">{
        schedule := models.OMESchedule{
                RunNow:    false,
                RunLater:  true,
                Cron:      plan.Cron.ValueString(),
                StartTime: "",
                EndTime:   "",
        }
        return schedule
}</span>

func getOptions(plan models.TemplateDeployment) models.OMEOptions <span class="cov8" title="1">{
        options := models.OMEOptions{
                ShutdownType:             0,
                TimeToWaitBeforeShutdown: plan.OptionsTimeToWaitBeforeShutdown.ValueInt64(),
                EndHostPowerState:        1,
                PrecheckOnly:             plan.OptionsPrecheckOnly.ValueBool(),
                ContinueOnWarning:        plan.OptionsContinueOnWarning.ValueBool(),
                StrictCheckingVLAN:       plan.OptionsStrictCheckingVlan.ValueBool(),
        }

        if plan.ForcedShutdown.ValueBool() </span><span class="cov8" title="1">{
                options.ShutdownType = 1
        }</span>

        <span class="cov8" title="1">if plan.PowerStateOff.ValueBool() </span><span class="cov8" title="1">{
                options.EndHostPowerState = 0
        }</span>
        <span class="cov8" title="1">return options</span>
}

func getBootToNetworkISO(ctx context.Context, plan models.TemplateDeployment) (models.OMENetworkBootISOModel, []diag.Diagnostic, error) <span class="cov8" title="1">{
        bootToNetworkISO := models.BootToNetworkISO{}
        diags := plan.BootToNetworkISO.As(ctx, &amp;bootToNetworkISO, basetypes.ObjectAsOptions{UnhandledNullAsEmpty: true})
        if diags.HasError() </span><span class="cov0" title="0">{
                return models.OMENetworkBootISOModel{}, diags, fmt.Errorf(clients.ErrUnableToParseBootToNetISO)
        }</span>

        <span class="cov8" title="1">shareDetail := models.ShareDetail{}
        diags = bootToNetworkISO.ShareDetail.As(ctx, &amp;shareDetail, basetypes.ObjectAsOptions{UnhandledNullAsEmpty: true})
        if diags.HasError() </span><span class="cov0" title="0">{
                return models.OMENetworkBootISOModel{}, diags, fmt.Errorf(clients.ErrUnableToParseBootToNetISO)
        }</span>

        <span class="cov8" title="1">bootToNetworkISOModel := models.OMENetworkBootISOModel{
                BootToNetwork:  bootToNetworkISO.BootToNetwork.ValueBool(),
                ISOPath:        bootToNetworkISO.IsoPath.ValueString(),
                ISOTimeout:     bootToNetworkISO.IsoTimeout.ValueInt64(),
                ISOTimeoutUnit: 2,
                ShareType:      bootToNetworkISO.ShareType.ValueString(),
                ShareDetail: models.OMEShareDetail{
                        IPAddress: shareDetail.IPAddress.ValueString(),
                        ShareName: shareDetail.ShareName.ValueString(),
                        WorkGroup: shareDetail.WorkGroup.ValueString(),
                        User:      shareDetail.User.ValueString(),
                        Password:  shareDetail.Password.ValueString(),
                },
        }
        return bootToNetworkISOModel, nil, nil</span>
}

func getDeviceAttributes(ctx context.Context, devices []models.Device, plan models.TemplateDeployment) []models.OMEDeviceAttributes <span class="cov8" title="1">{
        omeDeviceAttributes := []models.OMEDeviceAttributes{}
        deviceAttributes := []models.DeviceAttributes{}

        deviceMap := map[string]int64{}
        for _, d := range devices </span><span class="cov8" title="1">{
                deviceMap[d.DeviceServiceTag] = d.ID
        }</span>

        <span class="cov8" title="1">plan.DeviceAttributes.ElementsAs(ctx, &amp;deviceAttributes, true)
        for _, deviceAttribute := range deviceAttributes </span><span class="cov8" title="1">{
                omeDeviceAttribute := models.OMEDeviceAttributes{}
                attributeList := []models.Attribute{}
                deviceServiceTags := []string{}
                deviceAttribute.Attributes.ElementsAs(ctx, &amp;attributeList, true)
                deviceAttribute.DeviceServiceTags.ElementsAs(ctx, &amp;deviceServiceTags, true)
                omeAttributes := []models.OMEAttribute{}
                for _, attribute := range attributeList </span><span class="cov8" title="1">{
                        omeAttribute := models.OMEAttribute{
                                ID:        attribute.AttributeID.ValueInt64(),
                                Value:     attribute.Value.ValueString(),
                                IsIgnored: attribute.IsIgnored.ValueBool(),
                        }
                        omeAttributes = append(omeAttributes, omeAttribute)
                }</span>
                <span class="cov8" title="1">for _, deviceServiceTag := range deviceServiceTags </span><span class="cov8" title="1">{
                        if val, ok := deviceMap[deviceServiceTag]; ok </span><span class="cov8" title="1">{
                                omeDeviceAttribute.DeviceID = val
                                omeDeviceAttribute.Attributes = omeAttributes
                                omeDeviceAttributes = append(omeDeviceAttributes, omeDeviceAttribute)
                        }</span>
                }
        }
        <span class="cov8" title="1">return omeDeviceAttributes</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package ome

import (
        "context"
        "fmt"
        "reflect"
        "strconv"
        "strings"
        "terraform-provider-ome/clients"
        "terraform-provider-ome/models"
        "time"

        "github.com/hashicorp/terraform-plugin-framework/attr"
        "github.com/hashicorp/terraform-plugin-framework/resource"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema/listplanmodifier"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema/objectplanmodifier"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
        "github.com/hashicorp/terraform-plugin-framework/schema/validator"
        "github.com/hashicorp/terraform-plugin-framework/types"
        "github.com/hashicorp/terraform-plugin-framework/types/basetypes"
        "github.com/hashicorp/terraform-plugin-log/tflog"
)

const (
        //ComplianceViewTypeID - stores the id for the compliance view type.
        ComplianceViewTypeID = 1
        //DeploymentViewTypeID - stores the id for the deployment view type.
        DeploymentViewTypeID = 2
        //ChassisDeviceTypeID - stores the id for the Chassis device type type.
        ChassisDeviceTypeID = 4
        // RetryCount - stores the default value of retry count
        RetryCount = 5
        // SleepInterval - stores the default value of sleep interval
        SleepInterval = 30
        // SleepTimeBeforeJob - wait time in seconds before job tracking
        SleepTimeBeforeJob = 5
        // NicPortDivider - specifies divider used between NIC identifier and port
        NicPortDivider = "/"
        // NicIdentifierAndPort - key for identifying unique NIC in a Vlan
        NicIdentifierAndPort = "%s" + NicPortDivider + "%d"
)

// Ensure the implementation satisfies the expected interfaces.
var (
        _ resource.Resource                = &amp;resourceTemplate{}
        _ resource.ResourceWithConfigure   = &amp;resourceTemplate{}
        _ resource.ResourceWithImportState = &amp;resourceTemplate{}
)

// NewTemplateResource is new resource for template
func NewTemplateResource() resource.Resource <span class="cov8" title="1">{
        return &amp;resourceTemplate{}
}</span>

type resourceTemplate struct {
        p *omeProvider
}

// Configure implements resource.ResourceWithConfigure
func (r *resourceTemplate) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) <span class="cov8" title="1">{
        // panic("unimplemented")
        if req.ProviderData == nil </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">r.p = req.ProviderData.(*omeProvider)</span>
}

// Metadata implements resource.Resource
func (*resourceTemplate) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) <span class="cov8" title="1">{
        resp.TypeName = req.ProviderTypeName + "template"
}</span>

// Order Resource schema
func (r *resourceTemplate) Schema(_ context.Context, _ resource.SchemaRequest, resp *resource.SchemaResponse) <span class="cov8" title="1">{
        resp.Schema = schema.Schema{
                MarkdownDescription: "Resource for managing template on OpenManage Enterprise.Updates are supported for the following parameters: `name`, `description`, `attributes`, `job_retry_count`, `sleep_interval`, `identity_pool_name`, `vlan`.",
                Version:             1,
                Attributes: map[string]schema.Attribute{
                        "id": schema.StringAttribute{
                                MarkdownDescription: "ID of the template resource.",
                                Description:         "ID of the template resource.",
                                Computed:            true,
                        },
                        "name": schema.StringAttribute{
                                MarkdownDescription: "Name of the template resource.",
                                Description:         "Name of the template resource.",
                                Required:            true,
                        },
                        "fqdds": schema.StringAttribute{
                                MarkdownDescription: "Comma seperated values of components from a specified server, should be one of these iDRAC, System, BIOS, NIC, LifeCycleController, RAID, and EventFilters. This field cannot be updated.",
                                Description:         "Comma seperated values of components from a specified server, should be one of these iDRAC, System, BIOS, NIC, LifeCycleController, RAID, and EventFilters. This field cannot be updated.",
                                Optional:            true,
                                Computed:            true,
                                PlanModifiers: []planmodifier.String{
                                        StringDefaultValue(types.StringValue("All")),
                                },
                                Validators: []validator.String{
                                        validFqddsValidator{},
                                },
                        },
                        "view_type": schema.StringAttribute{
                                MarkdownDescription: "OME template view type, supported types are Deployment, Compliance. This field cannot be updated.",
                                Description:         "OME template view type, supported types are Deployment, Compliance. This field cannot be updated.",
                                Optional:            true,
                                Computed:            true,
                                PlanModifiers: []planmodifier.String{
                                        StringDefaultValue(types.StringValue("Deployment")),
                                },
                                Validators: []validator.String{
                                        validTemplateViewTypeValidator{},
                                },
                        },
                        "view_type_id": schema.Int64Attribute{
                                MarkdownDescription: "OME template view type id.",
                                Description:         "OME template view type id.",
                                Computed:            true,
                        },
                        "device_type": schema.StringAttribute{
                                MarkdownDescription: "OME template device type, supported types are Server, Chassis. This field cannot be updated and is applicable only for importing xml.",
                                Description:         "OME template device type, supported types are Server, Chassis. This field cannot be updated and is applicable only for importing xml.",
                                Optional:            true,
                                Computed:            true,
                                PlanModifiers: []planmodifier.String{
                                        StringDefaultValue(types.StringValue("Server")),
                                },
                                Validators: []validator.String{
                                        validTemplateDeviceTypeValidator{},
                                },
                        },
                        "content": schema.StringAttribute{
                                MarkdownDescription: "The XML content of template.. This field cannot be updated.",
                                Description:         "The XML content of template.. This field cannot be updated.",
                                Optional:            true,
                                Computed:            true,
                        },
                        "refdevice_servicetag": schema.StringAttribute{
                                MarkdownDescription: "Target device servicetag from which the template needs to be created. This field cannot be updated.",
                                Description:         "Target device servicetag from which the template needs to be created. This field cannot be updated.",
                                Optional:            true,
                                Computed:            true,
                        },
                        "refdevice_id": schema.Int64Attribute{
                                MarkdownDescription: "Target device id from which the template needs to be created. This field cannot be updated.",
                                Description:         "Target device id from which the template needs to be created. This field cannot be updated.",
                                Optional:            true,
                                Computed:            true,
                        },
                        "reftemplate_name": schema.StringAttribute{
                                MarkdownDescription: "Reference Template name from which the template needs to be cloned. This field cannot be updated.",
                                Description:         "Reference Template name from which the template needs to be cloned. This field cannot be updated.",
                                Optional:            true,
                                Computed:            true,
                        },
                        "description": schema.StringAttribute{
                                MarkdownDescription: "Description of the template",
                                Description:         "Description of the template",
                                Optional:            true,
                                Computed:            true,
                                PlanModifiers: []planmodifier.String{
                                        stringplanmodifier.UseStateForUnknown(),
                                },
                        },
                        "attributes": schema.ListAttribute{
                                MarkdownDescription: "List of attributes associated with a template. This field is ignored while creating a template.",
                                Description:         "List of attributes associated with a template. This field is ignored while creating a template.",
                                Optional:            true,
                                Computed:            true,
                                PlanModifiers: []planmodifier.List{
                                        listplanmodifier.UseStateForUnknown(),
                                },
                                ElementType: types.ObjectType{
                                        AttrTypes: map[string]attr.Type{
                                                "attribute_id": types.Int64Type,
                                                "display_name": types.StringType,
                                                "value":        types.StringType,
                                                "is_ignored":   types.BoolType,
                                        },
                                },
                        },
                        "job_retry_count": schema.Int64Attribute{
                                MarkdownDescription: "Number of times the job has to be polled to get the final status of the resource.",
                                Description:         "Number of times the job has to be polled to get the final status of the resource.",
                                Optional:            true,
                                Computed:            true,
                                PlanModifiers: []planmodifier.Int64{
                                        Int64DefaultValue(types.Int64Value(RetryCount)),
                                },
                        },
                        "sleep_interval": schema.Int64Attribute{
                                MarkdownDescription: "Sleep time interval for job polling in seconds.",
                                Description:         "Sleep time interval for job polling in seconds.",
                                Optional:            true,
                                Computed:            true,
                                PlanModifiers: []planmodifier.Int64{
                                        Int64DefaultValue(types.Int64Value(SleepInterval)),
                                },
                        },
                        "identity_pool_name": schema.StringAttribute{
                                MarkdownDescription: "Identity Pool name to be attached with template.",
                                Description:         "Identity Pool name to be attached with template.",
                                Optional:            true,
                                Computed:            true,
                                PlanModifiers: []planmodifier.String{
                                        stringplanmodifier.UseStateForUnknown(),
                                },
                        },
                        "identity_pool_id": schema.Int64Attribute{
                                MarkdownDescription: "ID of the Identity Pool attached with template.",
                                Description:         "ID of the Identity Pool attached with template.",
                                Computed:            true,
                        },
                        "vlan": schema.ObjectAttribute{
                                MarkdownDescription: "VLAN details to be attached with template.",
                                Description:         "VLAN details to be attached with template.",
                                Computed:            true,
                                Optional:            true,
                                PlanModifiers: []planmodifier.Object{
                                        objectplanmodifier.UseStateForUnknown(),
                                },
                                AttributeTypes: map[string]attr.Type{
                                        "propogate_vlan":     types.BoolType,
                                        "bonding_technology": types.StringType,
                                        "vlan_attributes": types.ListType{
                                                ElemType: types.ObjectType{
                                                        AttrTypes: map[string]attr.Type{
                                                                "untagged_network": types.Int64Type,
                                                                "tagged_networks": types.SetType{
                                                                        ElemType: types.Int64Type,
                                                                },
                                                                "is_nic_bonded":  types.BoolType,
                                                                "port":           types.Int64Type,
                                                                "nic_identifier": types.StringType,
                                                        },
                                                },
                                        },
                                },
                        },
                },
        }
}</span>

// Create a new resource
func (r *resourceTemplate) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) <span class="cov8" title="1">{
        //Read the data from Plan
        tflog.Trace(ctx, "resource_template create: started")
        var plan models.Template
        diags := req.Plan.Get(ctx, &amp;plan)
        resp.Diagnostics.Append(diags...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">tflog.Debug(ctx, "resource_template create: reference data", map[string]interface{}{
                "refdeviceid":         plan.RefdeviceID.ValueInt64(),
                "refdeviceservicetag": plan.RefdeviceServicetag,
                "refTemplate":         plan.ReftemplateName,
        })

        template := models.Template{}

        err := validateCreate(plan)
        if err != nil </span><span class="cov8" title="1">{
                resp.Diagnostics.AddError(
                        clients.ErrCreateTemplate, err.Error(),
                )
                return
        }</span>
        <span class="cov8" title="1">omeClient, err := clients.NewClient(*r.p.clientOpt)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        clients.ErrCreateClient,
                        err.Error(),
                )
                return
        }</span>

        <span class="cov8" title="1">_, err = omeClient.CreateSession()
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        clients.ErrCreateSession,
                        err.Error(),
                )
                return
        }</span>
        <span class="cov8" title="1">defer omeClient.RemoveSession()

        viewTypeID, err := omeClient.GetViewTypeID(plan.ViewType.ValueString())
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        clients.ErrCreateTemplate, err.Error(),
                )
                return
        }</span>

        <span class="cov8" title="1">deviceTypeID, err := omeClient.GetDeviceTypeID(plan.DeviceType.ValueString())
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        clients.ErrCreateTemplate, err.Error(),
                )
                return
        }</span>

        <span class="cov8" title="1">omeTemplateData := models.OMETemplate{}
        var templateID int64

        if plan.ReftemplateName.ValueString() != "" </span><span class="cov8" title="1">{
                tflog.Info(ctx, "resource_template create: creating a template from a reference template")

                if !plan.Description.IsUnknown() </span><span class="cov8" title="1">{
                        resp.Diagnostics.AddError(
                                clients.ErrCreateTemplate, "description cannot be modified while cloning from a reference template.",
                        )
                        return
                }</span>

                // The identity pool and Vlans does not get cloned into the new template in OME.
                <span class="cov8" title="1">sourceTemplate, err := omeClient.GetTemplateByName(plan.ReftemplateName.ValueString())
                if err != nil || sourceTemplate.Name == "" </span><span class="cov8" title="1">{
                        resp.Diagnostics.AddError(
                                clients.ErrCreateTemplate, "Unable to clone the template because Source template does not exist.",
                        )
                        return
                }</span>

                <span class="cov8" title="1">if sourceTemplate.ViewTypeID == ComplianceViewTypeID &amp;&amp; viewTypeID == DeploymentViewTypeID </span><span class="cov0" title="0">{
                        resp.Diagnostics.AddError(
                                clients.ErrCreateTemplate, "cannot clone compliance template as deployment template.",
                        )
                        return
                }</span>

                <span class="cov8" title="1">cloneTemplateRequest := models.OMECloneTemplate{
                        SourceTemplateID: sourceTemplate.ID,
                        NewTemplateName:  plan.Name.ValueString(),
                        ViewTypeID:       viewTypeID,
                }
                templateID, err = omeClient.CloneTemplateByRefTemplateID(cloneTemplateRequest)
                if err != nil </span><span class="cov0" title="0">{
                        resp.Diagnostics.AddError(
                                clients.ErrCreateTemplate, err.Error(),
                        )
                        return
                }</span>

                <span class="cov8" title="1">omeTemplateData, err = omeClient.GetTemplateByID(templateID)
                if err != nil </span><span class="cov0" title="0">{
                        resp.Diagnostics.AddError(
                                clients.ErrCreateTemplate, err.Error(),
                        )
                        return
                }</span>
        } else<span class="cov8" title="1"> if plan.Content.ValueString() != "" </span><span class="cov8" title="1">{ // template import
                tflog.Info(ctx, "resource_template create: creating a template from a xml content")

                if !plan.Description.IsUnknown() </span><span class="cov0" title="0">{
                        resp.Diagnostics.AddError(
                                clients.ErrCreateTemplate, "description is not supported for template import operation.",
                        )
                        return
                }</span>

                <span class="cov8" title="1">importTemplateRequest := models.OMEImportTemplate{
                        ViewTypeID: viewTypeID,
                        Type:       deviceTypeID,
                        Name:       plan.Name.ValueString(),
                        Content:    plan.Content.ValueString(),
                }

                templateID, err = omeClient.ImportTemplate(importTemplateRequest)
                if err != nil </span><span class="cov0" title="0">{
                        resp.Diagnostics.AddError(
                                clients.ErrCreateTemplate, err.Error(),
                        )
                        return
                }</span>

                <span class="cov8" title="1">omeTemplateData, err = omeClient.GetTemplateByID(templateID)
                if err != nil </span><span class="cov0" title="0">{
                        resp.Diagnostics.AddError(
                                clients.ErrCreateTemplate, err.Error(),
                        )
                        return
                }</span>

        } else<span class="cov8" title="1"> {
                tflog.Info(ctx, "resource_template create: creating a template from a reference device")
                deviceID, err := omeClient.ValidateDevice(plan.RefdeviceServicetag.ValueString(), plan.RefdeviceID.ValueInt64())
                if err != nil </span><span class="cov8" title="1">{
                        resp.Diagnostics.AddError(
                                clients.ErrCreateTemplate, err.Error(),
                        )
                        return
                }</span>

                <span class="cov8" title="1">ct := models.CreateTemplate{
                        Fqdds:          strings.ReplaceAll(plan.FQDDS.ValueString(), " ", ""),
                        ViewTypeID:     viewTypeID,
                        SourceDeviceID: deviceID,
                        Name:           plan.Name.ValueString(),
                        Description:    plan.Description.ValueString(),
                }

                templateID, err = omeClient.CreateTemplate(ct)
                if err != nil </span><span class="cov0" title="0">{
                        resp.Diagnostics.AddError(
                                clients.ErrCreateTemplate, err.Error(),
                        )
                        return
                }</span>

                <span class="cov8" title="1">tflog.Trace(ctx, fmt.Sprintf("template created with id %d", templateID))
                time.Sleep(SleepTimeBeforeJob * time.Second)
                omeTemplateData, err = omeClient.GetTemplateByID(templateID)
                if err != nil </span><span class="cov0" title="0">{
                        resp.Diagnostics.AddError(
                                clients.ErrCreateTemplate, err.Error(),
                        )
                        return
                }</span>

                <span class="cov8" title="1">isSuccess, message := omeClient.TrackJob(omeTemplateData.TaskID, plan.JobRetryCount.ValueInt64(), plan.SleepInterval.ValueInt64())
                if !isSuccess </span><span class="cov0" title="0">{
                        resp.Diagnostics.AddError(
                                clients.ErrCreateTemplate, message,
                        )
                        _, err = omeClient.Delete(fmt.Sprintf(clients.TemplateAPI+"(%d)", templateID), nil, nil)
                        if err != nil </span><span class="cov0" title="0">{
                                resp.Diagnostics.AddError(
                                        clients.ErrCreateTemplate,
                                        err.Error(),
                                )
                                return
                        }</span>
                        <span class="cov0" title="0">return</span>
                }
        }

        <span class="cov8" title="1">tflog.Trace(ctx, "resource_template create: fetching template attributes")

        omeAttributes, err := omeClient.GetTemplateAttributes(omeTemplateData.ID, []models.Attribute{}, true)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        clients.ErrCreateTemplate,
                        err.Error(),
                )
                return
        }</span>

        <span class="cov8" title="1">tflog.Trace(ctx, "resource_template create: fetching template valn data")
        omeVlan, err := omeClient.GetSchemaVlanData(templateID)
        if err != nil </span><span class="cov0" title="0">{
                if err != nil </span><span class="cov0" title="0">{
                        resp.Diagnostics.AddError(
                                clients.ErrCreateTemplate,
                                err.Error(),
                        )
                        return
                }</span>
        }
        //PropogateVlan is default true and is not available in the response from OME,hence setting it to true here to persist in state
        <span class="cov8" title="1">omeVlan.PropagateVLAN = true
        if !plan.RefdeviceServicetag.IsUnknown() </span><span class="cov8" title="1">{
                template.RefdeviceServicetag = plan.RefdeviceServicetag
        }</span>

        <span class="cov8" title="1">if !plan.ReftemplateName.IsUnknown() </span><span class="cov8" title="1">{
                template.ReftemplateName = plan.ReftemplateName
        }</span>

        <span class="cov8" title="1">if !plan.RefdeviceID.IsUnknown() </span><span class="cov8" title="1">{
                template.RefdeviceID = plan.RefdeviceID
        }</span>

        <span class="cov8" title="1">if plan.ReftemplateName.ValueString() != "" </span><span class="cov8" title="1">{
                template.RefdeviceID = types.Int64Value(omeTemplateData.SourceDeviceID)
        }</span>

        <span class="cov8" title="1">if !plan.Content.IsUnknown() </span><span class="cov8" title="1">{
                template.Content = plan.Content
        }</span>
        <span class="cov8" title="1">if !plan.ViewType.IsUnknown() </span><span class="cov8" title="1">{
                template.ViewType = plan.ViewType
        }</span>
        <span class="cov8" title="1">if !plan.DeviceType.IsUnknown() </span><span class="cov8" title="1">{
                template.DeviceType = plan.DeviceType
        }</span>
        <span class="cov8" title="1">if !plan.FQDDS.IsUnknown() </span><span class="cov8" title="1">{
                template.FQDDS = plan.FQDDS
        }</span> // The default value of fqdds is set to `All`. So if the config doesn't have any value specified, the default value in the plan is `All`.
        <span class="cov8" title="1">if !plan.JobRetryCount.IsUnknown() </span><span class="cov8" title="1">{
                template.JobRetryCount = plan.JobRetryCount
        }</span>
        <span class="cov8" title="1">if !plan.SleepInterval.IsUnknown() </span><span class="cov8" title="1">{
                template.SleepInterval = plan.SleepInterval
        }</span>
        <span class="cov8" title="1">if !plan.IdentityPoolName.IsUnknown() </span><span class="cov0" title="0">{
                template.IdentityPoolName = plan.IdentityPoolName
        }</span>

        <span class="cov8" title="1">tflog.Trace(ctx, "resource_template create: started updating state")

        updateState(&amp;template, []models.VlanAttributes{}, &amp;omeTemplateData, omeAttributes, omeVlan)

        tflog.Trace(ctx, "resource_template create: finished updating state")

        //Save into State if template creation is successful
        diags = resp.State.Set(ctx, &amp;template)
        resp.Diagnostics.Append(diags...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">tflog.Trace(ctx, "resource_template create: finished")</span>

}

// Read resource information
func (r *resourceTemplate) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) <span class="cov8" title="1">{
        tflog.Trace(ctx, "resource_template read: started")
        var template models.Template
        diags := req.State.Get(ctx, &amp;template)
        resp.Diagnostics.Append(diags...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">templateID, _ := strconv.ParseInt(template.ID.ValueString(), 10, 64)
        omeClient, err := clients.NewClient(*r.p.clientOpt)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        clients.ErrCreateClient,
                        err.Error(),
                )
                return
        }</span>

        <span class="cov8" title="1">_, err = omeClient.CreateSession()
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        clients.ErrCreateSession,
                        err.Error(),
                )
                return
        }</span>
        <span class="cov8" title="1">defer omeClient.RemoveSession()

        stateAttributes := []models.Attribute{}
        stateAttributeObjects := []types.Object{}
        template.Attributes.ElementsAs(ctx, &amp;stateAttributeObjects, true)

        for _, stateAttrObject := range stateAttributeObjects </span><span class="cov8" title="1">{
                stateAttribute := models.Attribute{}
                stateAttrObject.As(ctx, &amp;stateAttribute, basetypes.ObjectAsOptions{UnhandledNullAsEmpty: true})
                stateAttributes = append(stateAttributes, stateAttribute)
        }</span>

        <span class="cov8" title="1">tflog.Debug(ctx, "resource_template read: Template id", map[string]interface{}{
                "templateid": templateID,
        })

        omeTemplateData, err := omeClient.GetTemplateByID(templateID)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        clients.ErrReadTemplate, err.Error(),
                )
                return
        }</span>

        <span class="cov8" title="1">tflog.Trace(ctx, "resource_template read: fetching template attributes")

        omeAttributes, err := omeClient.GetTemplateAttributes(templateID, stateAttributes, true)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        clients.ErrReadTemplate,
                        fmt.Sprintf("Unable to refresh template attributes: %s", err.Error()),
                )
                return
        }</span>

        <span class="cov8" title="1">stateVlan := models.Vlan{}
        diags = template.Vlan.As(ctx, &amp;stateVlan, basetypes.ObjectAsOptions{UnhandledNullAsEmpty: true})
        if diags.HasError() </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        clients.ErrReadTemplate,
                        "Unable to fetch Vlan from state. Hence, Cannot refresh the template resource",
                )
                return
        }</span>
        <span class="cov8" title="1">tflog.Trace(ctx, "resource_template read: fetching template vlan data")

        omeVlan, err := omeClient.GetSchemaVlanData(templateID)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        clients.ErrReadTemplate,
                        fmt.Sprintf("Unable to refresh vlan attributes: %s", err.Error()),
                )
                return
        }</span>

        <span class="cov8" title="1">omeVlan.PropagateVLAN = stateVlan.PropogateVlan.ValueBool()

        if omeTemplateData.IdentityPoolID != 0 </span><span class="cov8" title="1">{
                identityPool, err := omeClient.GetIdentityPoolByID(omeTemplateData.IdentityPoolID)
                if err != nil </span><span class="cov0" title="0">{
                        resp.Diagnostics.AddError(
                                clients.ErrReadTemplate,
                                fmt.Sprintf("Unable to fetch the identity pools: %s", err.Error()),
                        )
                        return
                }</span>
                <span class="cov8" title="1">template.IdentityPoolName = types.StringValue(identityPool.Name)</span>
        }

        <span class="cov8" title="1">tflog.Trace(ctx, "resource_template read: updating state started")

        vlanAttrs := []models.VlanAttributes{}
        stateVlan.VlanAttributes.ElementsAs(ctx, &amp;vlanAttrs, true)

        updateState(&amp;template, vlanAttrs, &amp;omeTemplateData, omeAttributes, omeVlan)

        tflog.Trace(ctx, "resource_template read: updating state finished")

        diags = resp.State.Set(ctx, &amp;template)
        resp.Diagnostics.Append(diags...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">tflog.Trace(ctx, "resource_template read: finished")</span>
}

// Update resource
func (r resourceTemplate) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) <span class="cov8" title="1">{
        tflog.Trace(ctx, "resource_template update: started")
        var planTemplate models.Template
        planDiags := req.Plan.Get(ctx, &amp;planTemplate)
        resp.Diagnostics.Append(planDiags...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">var stateTemplate models.Template
        stateDiags := req.State.Get(ctx, &amp;stateTemplate)
        resp.Diagnostics.Append(stateDiags...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">templateID, _ := strconv.ParseInt(stateTemplate.ID.ValueString(), 10, 64)

        if isConfigValuesChanged(planTemplate, stateTemplate) </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        clients.ErrUpdateTemplate,
                        "cannot update the following fields : `refdevice_servicetag`,`refdevice_id`,`view_type`, `reftemplate_name`, `content` and `fqdds`",
                )
                return
        }</span>

        <span class="cov8" title="1">omeClient, err := clients.NewClient(*r.p.clientOpt)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        clients.ErrCreateClient,
                        err.Error(),
                )
                return
        }</span>

        <span class="cov8" title="1">_, err = omeClient.CreateSession()
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        clients.ErrCreateSession,
                        err.Error(),
                )
                return
        }</span>
        <span class="cov8" title="1">defer omeClient.RemoveSession()

        tflog.Debug(ctx, "resource_template update: Template id", map[string]interface{}{
                "templateid": templateID,
        })
        var identityPool models.IdentityPool
        if planTemplate.IdentityPoolName.ValueString() != "" </span><span class="cov8" title="1">{
                identityPool, err = validateIOPoolName(omeClient, planTemplate.IdentityPoolName.ValueString())
                if err != nil </span><span class="cov0" title="0">{
                        resp.Diagnostics.AddError(
                                clients.ErrUpdateTemplate,
                                err.Error(),
                        )
                        return
                }</span>
        }
        <span class="cov8" title="1">planVlan := getVlanForTemplate(ctx, resp, planTemplate)

        if !planTemplate.Vlan.IsUnknown() </span><span class="cov8" title="1">{
                err := validateVlanNetworkData(omeClient, templateID, planVlan)
                if err != nil </span><span class="cov8" title="1">{
                        resp.Diagnostics.AddError(
                                clients.ErrUpdateTemplate,
                                err.Error(),
                        )
                        return
                }</span>

        }

        <span class="cov8" title="1">updatePayload := models.UpdateTemplate{
                Name:        planTemplate.Name.ValueString(),
                ID:          templateID,
                Description: stateTemplate.Description.ValueString(),
        }

        if planTemplate.Description != stateTemplate.Description </span><span class="cov8" title="1">{
                updatePayload.Description = planTemplate.Description.ValueString()
        }</span>

        <span class="cov8" title="1">stateAttributes := getTfsdkStateAttributes(ctx, stateTemplate)
        // Terraform compares the list elements based on order, hence it is expected that the practitioner gives all attributes
        // along with the attribute for which modification is expected.
        da, _ := getDeltaAttributes(ctx, planTemplate, stateAttributes)

        tflog.Trace(ctx, "resource_template update: finished fetching delta attributes")

        if len(da) != 0 </span><span class="cov8" title="1">{
                tflog.Info(ctx, "resource_template update: delta attributes exists")
                updatePayload.Attributes = da
        }</span>

        <span class="cov8" title="1">tflog.Trace(ctx, "resource_template update: started a call to update template")
        err = omeClient.UpdateTemplate(updatePayload)
        if err != nil </span><span class="cov8" title="1">{
                resp.Diagnostics.AddError(
                        clients.ErrUpdateTemplate,
                        err.Error(),
                )
                return
        }</span>

        // Updating networkConfig now
        <span class="cov8" title="1">var updateIdentityPool = planTemplate.IdentityPoolName != stateTemplate.IdentityPoolName
        updateVlan := !reflect.DeepEqual(planTemplate.Vlan.Attributes(), stateTemplate.Vlan.Attributes())
        updateNetworkConfig := updateIdentityPool || updateVlan

        if updateNetworkConfig </span><span class="cov8" title="1">{
                tflog.Info(ctx, "resource_template update: updating network config")
                nwConfig := &amp;models.UpdateNetworkConfig{
                        TemplateID: templateID,
                }
                if updateIdentityPool </span><span class="cov8" title="1">{
                        tflog.Info(ctx, "resource_template update: updating identity pool")
                        // When IdentityPool is assigned to a  template for the first time, OME modifies the is_ignored parameter
                        // of the below parameters from True to False,
                        // ['IOIDOpt 1 Initiator Persistence Policy', 'IOIDOpt 1 Storage Target Persistence Policy',
                        // 'OIDOpt 1 Virtual Address Persistence Policy Auxiliary Powered',
                        // 'IOIDOpt 1 Virtual Address Persistence Policy Non Auxiliary Powered']. This will cause an inconsistency between plan and state.
                        // Hence, before IO pool is assigned, these attributes will have to be modified.
                        if planTemplate.IdentityPoolName.ValueString() != "" </span><span class="cov8" title="1">{
                                nwConfig.IdentityPoolID = identityPool.ID
                        }</span> else<span class="cov0" title="0"> {
                                nwConfig.IdentityPoolID = 0
                        }</span>
                } else<span class="cov0" title="0"> {
                        nwConfig.IdentityPoolID = stateTemplate.IdentityPoolID.ValueInt64()
                }</span>
                <span class="cov8" title="1">if planTemplate.IdentityPoolName.ValueString() != "" </span><span class="cov8" title="1">{
                        identityPool, err := omeClient.GetIdentityPoolByName(planTemplate.IdentityPoolName.ValueString())
                        if err != nil </span><span class="cov0" title="0">{
                                resp.Diagnostics.AddWarning(
                                        fmt.Sprintf("Unable to update IdentityPool parameters to the template: %d", templateID),
                                        err.Error(),
                                )
                        }</span> else<span class="cov8" title="1"> {
                                nwConfig.IdentityPoolID = identityPool.ID
                        }</span>
                } else<span class="cov0" title="0"> {
                        nwConfig.IdentityPoolID = 0
                }</span>
                <span class="cov8" title="1">if updateVlan </span><span class="cov8" title="1">{
                        tflog.Info(ctx, "resource_template update: updating vlan attrs")
                        vlanNetworkView, err := omeClient.GetVlanNetworkModel(templateID)
                        if err != nil </span><span class="cov0" title="0">{
                                resp.Diagnostics.AddWarning(
                                        clients.ErrUpdateTemplate,
                                        fmt.Sprintf("unable to fetch network view from OME to update vlan to the template: %d, Error: %s", templateID, err.Error()),
                                )
                        }</span> else<span class="cov8" title="1"> {
                                tflog.Info(ctx, "resource_template update: fetching vlan attrs")
                                stateVlan := getVlanForTemplate(ctx, resp, stateTemplate)
                                // when tagged networks are to be removed, its expected that the practitioner would give input as [0],
                                // Provider will convert this to [] and send to API. [0] will be written back to state file to make plan
                                //and state consistent.
                                tflog.Info(ctx, "resource_template update: updating vlan attrs has no errors")
                                deltaVlan := getDeltaVlan(ctx, planVlan, stateVlan)
                                nwConfig.BondingTechnology = deltaVlan.BondingTechnology
                                nwConfig.PropagateVLAN = deltaVlan.PropagateVLAN
                                payloadVlanAttributes := []models.PayloadVlanAttribute{}
                                for _, deltaVlanAttr := range deltaVlan.OMEVlanAttributes </span><span class="cov8" title="1">{
                                        payloadVlanAttr, _ := omeClient.GetPayloadVlanAttribute(vlanNetworkView, deltaVlanAttr.NicIdentifier, deltaVlanAttr.Port)
                                        payloadVlanAttr.Tagged = deltaVlanAttr.Tagged
                                        payloadVlanAttr.Untagged = deltaVlanAttr.Untagged
                                        payloadVlanAttr.IsNICBonded = deltaVlanAttr.IsNICBonded
                                        payloadVlanAttributes = append(payloadVlanAttributes, payloadVlanAttr)
                                }</span>
                                <span class="cov8" title="1">nwConfig.VLANAttributes = payloadVlanAttributes</span>
                        }

                }
                <span class="cov8" title="1">tflog.Info(ctx, "resource_template update: triggering update netowrk config")
                err = omeClient.UpdateNetworkConfig(nwConfig)
                if err != nil </span><span class="cov0" title="0">{
                        resp.Diagnostics.AddWarning(
                                clients.ErrUpdateTemplate,
                                fmt.Sprintf("unable to update network configuration to the template: %d, Error: %s", templateID, err.Error()),
                        )
                }</span>

        }

        <span class="cov8" title="1">tflog.Trace(ctx, "resource_template update: fetching template by id")
        omeTemplateData, err := omeClient.GetTemplateByID(templateID)

        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        clients.ErrUpdateTemplate, err.Error(),
                )
                return
        }</span>

        <span class="cov8" title="1">tflog.Trace(ctx, "resource_template update: fetching template attributes")

        omeAttributes, err := omeClient.GetTemplateAttributes(templateID, stateAttributes, true)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        clients.ErrUpdateTemplate,
                        fmt.Sprintf("unable to refresh template attributes: %s", err.Error()),
                )
                return
        }</span>

        <span class="cov8" title="1">tflog.Trace(ctx, "resource_template update: fetching vlan data")

        updatedVlan, err := omeClient.GetSchemaVlanData(templateID)
        if err != nil </span><span class="cov0" title="0">{
                if err != nil </span><span class="cov0" title="0">{
                        resp.Diagnostics.AddError(
                                clients.ErrUpdateTemplate,
                                fmt.Sprintf("unable to refresh vlan attributes: %s", err.Error()),
                        )
                        return
                }</span>
        }

        <span class="cov8" title="1">updatedVlan.PropagateVLAN = planVlan.PropagateVLAN

        if !planTemplate.IdentityPoolName.IsUnknown() </span><span class="cov8" title="1">{
                stateTemplate.IdentityPoolName = planTemplate.IdentityPoolName
        }</span>

        <span class="cov8" title="1">if !planTemplate.SleepInterval.IsUnknown() </span><span class="cov8" title="1">{
                stateTemplate.SleepInterval = planTemplate.SleepInterval
        }</span>

        <span class="cov8" title="1">if !planTemplate.ViewType.IsUnknown() </span><span class="cov8" title="1">{
                stateTemplate.ViewType = planTemplate.ViewType
        }</span>

        <span class="cov8" title="1">if !planTemplate.FQDDS.IsUnknown() </span><span class="cov8" title="1">{
                stateTemplate.FQDDS = planTemplate.FQDDS
        }</span>

        <span class="cov8" title="1">if !planTemplate.JobRetryCount.IsUnknown() </span><span class="cov8" title="1">{
                stateTemplate.JobRetryCount = planTemplate.JobRetryCount
        }</span>

        <span class="cov8" title="1">tflog.Trace(ctx, "resource_template update: updating state data started")

        tfsdkVlan := models.Vlan{}
        planTemplate.Vlan.As(ctx, &amp;tfsdkVlan, basetypes.ObjectAsOptions{UnhandledNullAsEmpty: true})

        vlanAttrs := []models.VlanAttributes{}
        tfsdkVlan.VlanAttributes.ElementsAs(ctx, &amp;vlanAttrs, true)

        updateState(&amp;stateTemplate, vlanAttrs, &amp;omeTemplateData, omeAttributes, updatedVlan)

        tflog.Trace(ctx, "resource_template update: updating state data finished")
        //Save into State if template update is successful
        diags := resp.State.Set(ctx, &amp;stateTemplate)

        resp.Diagnostics.Append(diags...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">tflog.Trace(ctx, "resource_template update: finished")</span>
}

// Delete resource
func (r resourceTemplate) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) <span class="cov8" title="1">{
        tflog.Trace(ctx, "resource_template delete: started")
        var template models.Template
        diags := resp.State.Get(ctx, &amp;template)
        resp.Diagnostics.Append(diags...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">omeClient, err := clients.NewClient(*r.p.clientOpt)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        clients.ErrCreateClient,
                        err.Error(),
                )
                return
        }</span>

        <span class="cov8" title="1">_, err = omeClient.CreateSession()
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        clients.ErrCreateSession,
                        err.Error(),
                )
                return
        }</span>
        <span class="cov8" title="1">defer omeClient.RemoveSession()
        tflog.Trace(ctx, "resource_template delete: started delete")
        tflog.Debug(ctx, "resource_template delete: started delete for template", map[string]interface{}{
                "templateid": template.ID.ValueString(),
        })

        _, err = omeClient.Delete(fmt.Sprintf(clients.TemplateAPI+"(%s)", template.ID.ValueString()), nil, nil)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        clients.ErrDeleteTemplate,
                        err.Error(),
                )
                return
        }</span>
        <span class="cov8" title="1">tflog.Trace(ctx, "resource_template delete: finished")</span>
}

// Import resource
func (r resourceTemplate) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) <span class="cov8" title="1">{
        tflog.Trace(ctx, "resource_template import: started")
        var template models.Template
        template.Name = types.StringValue(req.ID)
        omeClient, err := clients.NewClient(*r.p.clientOpt)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        clients.ErrCreateClient,
                        err.Error(),
                )
                return
        }</span>

        <span class="cov8" title="1">_, err = omeClient.CreateSession()
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        clients.ErrCreateSession,
                        err.Error(),
                )
                return
        }</span>
        <span class="cov8" title="1">defer omeClient.RemoveSession()

        omeTemplateData, err := omeClient.GetTemplateByName(req.ID)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        clients.ErrImportTemplate, err.Error(),
                )
                return
        }</span>

        <span class="cov8" title="1">if omeTemplateData.ID == 0 </span><span class="cov8" title="1">{
                resp.Diagnostics.AddError(
                        clients.ErrImportTemplate, "invalid template name",
                )
                return
        }</span>

        <span class="cov8" title="1">omeAttributes, err := omeClient.GetTemplateAttributes(omeTemplateData.ID, []models.Attribute{}, true)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        clients.ErrImportTemplate,
                        fmt.Sprintf("unable to get template attributes: %s", err.Error()),
                )
                return
        }</span>

        <span class="cov8" title="1">omeVlan, err := omeClient.GetSchemaVlanData(omeTemplateData.ID)
        if err != nil </span><span class="cov0" title="0">{
                if err != nil </span><span class="cov0" title="0">{
                        resp.Diagnostics.AddError(
                                clients.ErrImportTemplate,
                                fmt.Sprintf("Unable to refresh vlan attributes: %s", err.Error()),
                        )
                        return
                }</span>
        }
        <span class="cov8" title="1">tflog.Trace(ctx, "resource_template import: started state update")

        updateState(&amp;template, []models.VlanAttributes{}, &amp;omeTemplateData, omeAttributes, omeVlan)
        tflog.Trace(ctx, "resource_template import: finished state update")

        viewType := "Deployment"
        if omeTemplateData.ViewTypeID == ComplianceViewTypeID </span><span class="cov0" title="0">{
                viewType = "Compliance"
        }</span>

        <span class="cov8" title="1">deviceType := "Server"
        if omeTemplateData.TypeID == ChassisDeviceTypeID </span><span class="cov0" title="0">{
                deviceType = "Chassis"
        }</span>

        <span class="cov8" title="1">template.RefdeviceID = types.Int64Value(omeTemplateData.SourceDeviceID)
        template.RefdeviceServicetag = types.StringValue("NA")
        template.ReftemplateName = types.StringValue("NA")
        template.Content = types.StringValue("NA")
        template.ViewType = types.StringValue(viewType)
        template.DeviceType = types.StringValue(deviceType)
        template.JobRetryCount = types.Int64Value(RetryCount)
        template.SleepInterval = types.Int64Value(SleepInterval)
        template.FQDDS = types.StringValue("All")
        diags := resp.State.Set(ctx, &amp;template)
        resp.Diagnostics.Append(diags...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">tflog.Trace(ctx, "resource_template import: finished")</span>
}

func validateCreate(plan models.Template) error <span class="cov8" title="1">{
        // all references cannot be empty
        if plan.ReftemplateName.ValueString() == "" &amp;&amp; plan.RefdeviceID.ValueInt64() == 0 &amp;&amp; plan.RefdeviceServicetag.ValueString() == "" &amp;&amp; plan.Content.ValueString() == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("either reftemplate_name or refdevice_id or refdevice_servicetag or content is required")
        }</span>

        // any two references given results in error
        <span class="cov8" title="1">if (plan.ReftemplateName.ValueString() != "" &amp;&amp; (plan.RefdeviceID.ValueInt64() != 0 || plan.RefdeviceServicetag.ValueString() != "" || plan.Content.ValueString() != "")) ||
                (plan.RefdeviceID.ValueInt64() != 0 &amp;&amp; (plan.ReftemplateName.ValueString() != "" || plan.RefdeviceServicetag.ValueString() != "" || plan.Content.ValueString() != "")) ||
                (plan.RefdeviceServicetag.ValueString() != "" &amp;&amp; (plan.RefdeviceID.ValueInt64() != 0 || plan.ReftemplateName.ValueString() != "" || plan.Content.ValueString() != "")) ||
                (plan.Content.ValueString() != "" &amp;&amp; (plan.RefdeviceID.ValueInt64() != 0 || plan.ReftemplateName.ValueString() != "" || plan.RefdeviceServicetag.ValueString() != "")) </span><span class="cov8" title="1">{
                return fmt.Errorf("either reftemplate_name or refdevice_id or refdevice_servicetag or content is required")
        }</span>

        // Identity Pool name and Vlan is supported only during update
        <span class="cov8" title="1">if !plan.IdentityPoolName.IsUnknown() || !plan.Vlan.IsUnknown() </span><span class="cov8" title="1">{
                return fmt.Errorf("attributes identity_pool_name and vlan cannot be associated during create")
        }</span>

        // Attributes is part of plan during create
        <span class="cov8" title="1">if !plan.Attributes.IsUnknown() </span><span class="cov0" title="0">{
                return fmt.Errorf("attributes cannot be modified during create")
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func validateVlanNetworkData(omeClient *clients.Client, templateID int64, planVlan models.OMEVlan) error <span class="cov8" title="1">{
        remoteVlanFromTemplate, err := omeClient.GetSchemaVlanData(templateID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">vlanNetworks, err := omeClient.GetAllVlanNetworks()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">err = validateVlan(planVlan, remoteVlanFromTemplate, vlanNetworks)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func validateIOPoolName(omeClient *clients.Client, name string) (models.IdentityPool, error) <span class="cov8" title="1">{
        identityPool, err := omeClient.GetIdentityPoolByName(name)
        if err != nil </span><span class="cov0" title="0">{
                return identityPool, err
        }</span>
        <span class="cov8" title="1">return identityPool, nil</span>
}

func isConfigValuesChanged(planTemplate, stateTemplate models.Template) bool <span class="cov8" title="1">{
        return (!planTemplate.RefdeviceID.IsUnknown() &amp;&amp; stateTemplate.RefdeviceID.ValueInt64() != planTemplate.RefdeviceID.ValueInt64()) ||
                (!planTemplate.RefdeviceServicetag.IsUnknown() &amp;&amp; stateTemplate.RefdeviceServicetag.ValueString() != planTemplate.RefdeviceServicetag.ValueString()) ||
                (!planTemplate.ViewType.IsUnknown() &amp;&amp; stateTemplate.ViewType.ValueString() != planTemplate.ViewType.ValueString()) ||
                (!planTemplate.FQDDS.IsUnknown() &amp;&amp; stateTemplate.FQDDS.ValueString() != planTemplate.FQDDS.ValueString()) ||
                (!planTemplate.ReftemplateName.IsUnknown() &amp;&amp; stateTemplate.ReftemplateName.ValueString() != planTemplate.ReftemplateName.ValueString()) ||
                (!planTemplate.Content.IsUnknown() &amp;&amp; stateTemplate.Content.ValueString() != planTemplate.Content.ValueString())
}</span>

func validateVlan(planVlan, remoteVlan models.OMEVlan, vlanNetworks []models.VLanNetworks) error <span class="cov8" title="1">{
        if len(remoteVlan.OMEVlanAttributes) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("vlan attributes are not available in the template")
        }</span>
        <span class="cov8" title="1">if len(planVlan.OMEVlanAttributes) != len(remoteVlan.OMEVlanAttributes) </span><span class="cov8" title="1">{
                return fmt.Errorf("number of port and nic identifier is inconsistent with the template")
        }</span>
        <span class="cov8" title="1">remoteVlanIdentifiers := make(map[string]bool)
        var invalidNetworkIDs []int64
        for _, vlanAttr := range remoteVlan.OMEVlanAttributes </span><span class="cov8" title="1">{
                key := fmt.Sprintf(NicIdentifierAndPort, vlanAttr.NicIdentifier, vlanAttr.Port)
                remoteVlanIdentifiers[key] = true
        }</span>
        <span class="cov8" title="1">var remoteVlanNetworkIDs = map[int64]bool{0: true}
        for _, vn := range vlanNetworks </span><span class="cov8" title="1">{
                remoteVlanNetworkIDs[vn.ID] = true
        }</span>

        <span class="cov8" title="1">dupTagNetworkIDs := map[string][]int64{}
        networkKeys := []string{}

        for _, planVlanAttr := range planVlan.OMEVlanAttributes </span><span class="cov8" title="1">{
                key := fmt.Sprintf(NicIdentifierAndPort, planVlanAttr.NicIdentifier, planVlanAttr.Port)
                if _, ok := remoteVlanIdentifiers[key]; !ok </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid combination of Nic Identifier and Port %s", key)
                }</span>
                <span class="cov8" title="1">networkKeys = append(networkKeys, key)
                untagged := planVlanAttr.Untagged
                if !isValidNetworkID(remoteVlanNetworkIDs, untagged) </span><span class="cov0" title="0">{
                        invalidNetworkIDs = append(invalidNetworkIDs, untagged)
                }</span>
                <span class="cov8" title="1">taggedNetworkMap := map[int64]bool{}
                dupNetworkTag := []int64{}

                for _, tag := range planVlanAttr.Tagged </span><span class="cov8" title="1">{
                        if _, ok := taggedNetworkMap[tag]; ok </span><span class="cov0" title="0">{
                                dupNetworkTag = append(dupNetworkTag, tag)
                        }</span>
                        <span class="cov8" title="1">taggedNetworkMap[tag] = true
                        if !isValidNetworkID(remoteVlanNetworkIDs, tag) </span><span class="cov0" title="0">{
                                invalidNetworkIDs = append(invalidNetworkIDs, tag)
                        }</span>
                }
                <span class="cov8" title="1">if len(dupNetworkTag) != 0 </span><span class="cov0" title="0">{
                        fmtKey := strings.Replace(key, NicPortDivider, ", Port: ", 1)
                        dupTagNetworkIDs[fmtKey] = dupNetworkTag
                }</span>
        }

        <span class="cov8" title="1">isDuplicate := hasDuplicates(networkKeys)
        if len(networkKeys) != len(isDuplicate) </span><span class="cov0" title="0">{
                return fmt.Errorf("duplicate combination of Nic Identifier/Port %v ", isDuplicate)
        }</span>

        <span class="cov8" title="1">if len(dupTagNetworkIDs) != 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("duplicate vlan network IDs %v ", dupTagNetworkIDs)
        }</span>

        <span class="cov8" title="1">if len(invalidNetworkIDs) != 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid vlan network IDs %v ", unique(invalidNetworkIDs))
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func unique(intSlice []int64) []int64 <span class="cov0" title="0">{
        keys := make(map[int64]bool)
        list := []int64{}
        for _, entry := range intSlice </span><span class="cov0" title="0">{
                if _, value := keys[entry]; !value </span><span class="cov0" title="0">{
                        keys[entry] = true
                        list = append(list, entry)
                }</span>
        }
        <span class="cov0" title="0">return list</span>
}

func hasDuplicates(strArr []string) []string <span class="cov8" title="1">{
        uniqueMap := make(map[string]bool)
        var uniqueNames []string
        for _, str := range strArr </span><span class="cov8" title="1">{
                if _, exists := uniqueMap[str]; !exists </span><span class="cov8" title="1">{
                        uniqueMap[str] = true
                        uniqueNames = append(uniqueNames, str)
                }</span>
        }
        <span class="cov8" title="1">return uniqueNames</span>
}

func isValidNetworkID(remoteVlanIds map[int64]bool, vlanID int64) bool <span class="cov8" title="1">{
        if _, ok := remoteVlanIds[vlanID]; !ok </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">return true</span>
}

func getVlanForTemplate(ctx context.Context, resp *resource.UpdateResponse, Template models.Template) models.OMEVlan <span class="cov8" title="1">{
        omeVlan := models.OMEVlan{}
        vlan := models.Vlan{}

        Template.Vlan.As(ctx, &amp;vlan, basetypes.ObjectAsOptions{UnhandledNullAsEmpty: true})
        omeVlan.BondingTechnology = vlan.BondingTechnology.ValueString()
        omeVlan.PropagateVLAN = vlan.PropogateVlan.ValueBool()
        omeVlanAttrs := []models.OMEVlanAttribute{}
        vlanAttrs := []models.VlanAttributes{}
        vlan.VlanAttributes.ElementsAs(ctx, &amp;vlanAttrs, true)
        for _, vlanAttr := range vlanAttrs </span><span class="cov8" title="1">{
                taggedNetworks := []int64{}
                vlanAttr.TaggedNetworks.ElementsAs(ctx, &amp;taggedNetworks, true)
                omeVlanAttr := models.OMEVlanAttribute{
                        Untagged:      vlanAttr.UntaggedNetwork.ValueInt64(),
                        Tagged:        taggedNetworks,
                        IsNICBonded:   vlanAttr.IsNicBonded.ValueBool(),
                        Port:          vlanAttr.Port.ValueInt64(),
                        NicIdentifier: vlanAttr.NicIdentifier.ValueString(),
                }
                omeVlanAttrs = append(omeVlanAttrs, omeVlanAttr)
        }</span>
        <span class="cov8" title="1">omeVlan.OMEVlanAttributes = omeVlanAttrs
        return omeVlan</span>
}

func getTfsdkStateAttributes(ctx context.Context, stateTemplate models.Template) []models.Attribute <span class="cov8" title="1">{
        stateAttributes := []models.Attribute{}
        stateAttributeObjects := []types.Object{}
        stateTemplate.Attributes.ElementsAs(ctx, &amp;stateAttributeObjects, true)

        for _, stateAttrObject := range stateAttributeObjects </span><span class="cov8" title="1">{
                stateAttribute := models.Attribute{}
                stateAttrObject.As(ctx, &amp;stateAttribute, basetypes.ObjectAsOptions{UnhandledNullAsEmpty: true})
                stateAttributes = append(stateAttributes, stateAttribute)
        }</span>
        <span class="cov8" title="1">return stateAttributes</span>
}

func getDeltaVlan(ctx context.Context, planVlan, stateVlan models.OMEVlan) models.OMEVlan <span class="cov8" title="1">{
        deltaVlan := models.OMEVlan{}
        deltaVlan.BondingTechnology = planVlan.BondingTechnology
        deltaVlan.PropagateVLAN = planVlan.PropagateVLAN
        deltaVlanAttributes := []models.OMEVlanAttribute{}
        for index, vlanAttr := range planVlan.OMEVlanAttributes </span><span class="cov8" title="1">{
                if !reflect.DeepEqual(vlanAttr, stateVlan.OMEVlanAttributes[index]) </span><span class="cov8" title="1">{
                        if len(vlanAttr.Tagged) == 1 &amp;&amp; vlanAttr.Tagged[0] == 0 </span><span class="cov8" title="1">{
                                vlanAttr.Tagged = []int64{}
                        }</span>
                        <span class="cov8" title="1">deltaVlanAttributes = append(deltaVlanAttributes, vlanAttr)</span>
                }

        }
        <span class="cov8" title="1">deltaVlan.OMEVlanAttributes = deltaVlanAttributes
        return deltaVlan</span>
}

func getDeltaAttributes(ctx context.Context, planTemplate models.Template, stateAttributes []models.Attribute) ([]models.UpdateAttribute, error) <span class="cov8" title="1">{
        updatedAttributes := []models.UpdateAttribute{}

        planUpdateAttributes := []models.Attribute{}
        planUpdateAttributeObjects := []types.Object{}
        planTemplate.Attributes.ElementsAs(ctx, &amp;planUpdateAttributeObjects, true)

        for _, planUpdateAttrObject := range planUpdateAttributeObjects </span><span class="cov8" title="1">{
                planUpdateAttribute := models.Attribute{}
                planUpdateAttrObject.As(ctx, &amp;planUpdateAttribute, basetypes.ObjectAsOptions{UnhandledNullAsEmpty: true})
                planUpdateAttributes = append(planUpdateAttributes, planUpdateAttribute)
        }</span>
        <span class="cov8" title="1">if !reflect.DeepEqual(planUpdateAttributes, stateAttributes) </span><span class="cov8" title="1">{
                for index, attribute := range planUpdateAttributes </span><span class="cov8" title="1">{
                        if attribute.Value != stateAttributes[index].Value </span><span class="cov8" title="1">{
                                updateAttribute := models.UpdateAttribute{
                                        ID:        attribute.AttributeID.ValueInt64(),
                                        IsIgnored: attribute.IsIgnored.ValueBool(),
                                        Value:     attribute.Value.ValueString(),
                                }
                                updatedAttributes = append(updatedAttributes, updateAttribute)
                        }</span>
                }
        }

        <span class="cov8" title="1">return updatedAttributes, nil</span>
}

func updateState(stateTemplate *models.Template, planVlanAttributes []models.VlanAttributes, omeTemplateData *models.OMETemplate, omeTemplateAttributes []models.OmeAttribute, omeVlan models.OMEVlan) <span class="cov8" title="1">{

        stateTemplate.ID = types.StringValue(fmt.Sprintf("%d", omeTemplateData.ID))
        stateTemplate.Name = types.StringValue(omeTemplateData.Name)
        stateTemplate.Description = types.StringValue(omeTemplateData.Description)
        stateTemplate.ViewTypeID = types.Int64Value(omeTemplateData.ViewTypeID)
        stateTemplate.IdentityPoolID = types.Int64Value(omeTemplateData.IdentityPoolID)

        attributeObjects := []attr.Value{}

        for _, attribute := range omeTemplateAttributes </span><span class="cov8" title="1">{
                attributeDetails := map[string]attr.Value{}
                attributeDetails["attribute_id"] = types.Int64Value(attribute.AttributeID)
                attributeDetails["display_name"] = types.StringValue(attribute.DisplayName)
                attributeDetails["value"] = types.StringValue(attribute.Value)
                attributeDetails["is_ignored"] = types.BoolValue(attribute.IsIgnored)
                attributeObject, _ := types.ObjectValue(
                        map[string]attr.Type{
                                "attribute_id": types.Int64Type,
                                "display_name": types.StringType,
                                "value":        types.StringType,
                                "is_ignored":   types.BoolType,
                        }, attributeDetails)
                attributeObjects = append(attributeObjects, attributeObject)
        }</span>
        <span class="cov8" title="1">attributesTfsdk, _ := types.ListValue(
                types.ObjectType{
                        AttrTypes: map[string]attr.Type{
                                "attribute_id": types.Int64Type,
                                "display_name": types.StringType,
                                "value":        types.StringType,
                                "is_ignored":   types.BoolType,
                        },
                }, attributeObjects)
        stateTemplate.Attributes = attributesTfsdk

        omeVlanMap := map[string]models.OMEVlanAttribute{}

        for _, vlanAttr := range omeVlan.OMEVlanAttributes </span><span class="cov8" title="1">{
                key := fmt.Sprintf(NicIdentifierAndPort, vlanAttr.NicIdentifier, vlanAttr.Port)
                omeVlanMap[key] = vlanAttr
        }</span>

        <span class="cov8" title="1">vlanAttrsObjects := []attr.Value{}

        for _, planVlanAttr := range planVlanAttributes </span><span class="cov8" title="1">{
                key := fmt.Sprintf(NicIdentifierAndPort, planVlanAttr.NicIdentifier.ValueString(), planVlanAttr.Port.ValueInt64())
                if omeVlanAttr, ok := omeVlanMap[key]; ok </span><span class="cov8" title="1">{
                        vlanAttrObject := getVlanAtrrObject(omeVlanAttr)
                        vlanAttrsObjects = append(vlanAttrsObjects, vlanAttrObject)

                        delete(omeVlanMap, key)
                }</span>
        }

        <span class="cov8" title="1">if len(omeVlanMap) != 0 </span><span class="cov8" title="1">{
                for _, omeVlanAttr := range omeVlanMap </span><span class="cov8" title="1">{
                        vlanAttrObject := getVlanAtrrObject(omeVlanAttr)
                        vlanAttrsObjects = append(vlanAttrsObjects, vlanAttrObject)
                }</span>
        }

        <span class="cov8" title="1">vlanAttrList, _ := types.ListValue(
                types.ObjectType{
                        AttrTypes: map[string]attr.Type{
                                "untagged_network": types.Int64Type,
                                "tagged_networks": types.SetType{
                                        ElemType: types.Int64Type,
                                },
                                "is_nic_bonded":  types.BoolType,
                                "port":           types.Int64Type,
                                "nic_identifier": types.StringType,
                        },
                }, vlanAttrsObjects)

        vlanTfsdk, _ := types.ObjectValue(
                map[string]attr.Type{
                        "propogate_vlan":     types.BoolType,
                        "bonding_technology": types.StringType,
                        "vlan_attributes": types.ListType{
                                ElemType: types.ObjectType{
                                        AttrTypes: map[string]attr.Type{
                                                "untagged_network": types.Int64Type,
                                                "tagged_networks": types.SetType{
                                                        ElemType: types.Int64Type,
                                                },
                                                "is_nic_bonded":  types.BoolType,
                                                "port":           types.Int64Type,
                                                "nic_identifier": types.StringType,
                                        },
                                },
                        },
                },
                map[string]attr.Value{
                        "propogate_vlan":     types.BoolValue(omeVlan.PropagateVLAN),
                        "bonding_technology": types.StringValue(omeVlan.BondingTechnology),
                        "vlan_attributes":    vlanAttrList,
                },
        )

        stateTemplate.Vlan = vlanTfsdk</span>
}

func getVlanAtrrObject(omeVlanAttr models.OMEVlanAttribute) types.Object <span class="cov8" title="1">{
        vlanAttrMap := map[string]attr.Value{}
        vlanAttrMap["untagged_network"] = types.Int64Value(omeVlanAttr.Untagged)
        taggedNetworks := []attr.Value{}
        for _, tn := range omeVlanAttr.Tagged </span><span class="cov8" title="1">{
                taggedNetworks = append(taggedNetworks, types.Int64Value(tn))
        }</span>

        <span class="cov8" title="1">vlanAttrMap["tagged_networks"], _ = types.SetValue(
                types.Int64Type,
                taggedNetworks,
        )
        vlanAttrMap["is_nic_bonded"] = types.BoolValue(omeVlanAttr.IsNICBonded)
        vlanAttrMap["port"] = types.Int64Value(omeVlanAttr.Port)
        vlanAttrMap["nic_identifier"] = types.StringValue(omeVlanAttr.NicIdentifier)
        vlanAttrObject, _ := types.ObjectValue(
                map[string]attr.Type{
                        "untagged_network": types.Int64Type,
                        "tagged_networks": types.SetType{
                                ElemType: types.Int64Type,
                        },
                        "is_nic_bonded":  types.BoolType,
                        "port":           types.Int64Type,
                        "nic_identifier": types.StringType,
                }, vlanAttrMap)
        return vlanAttrObject</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package ome

import (
        "context"
        "fmt"
        "strings"
        "terraform-provider-ome/clients"

        "github.com/hashicorp/terraform-plugin-framework/schema/validator"
)

var _ validator.String = &amp;validFqddsValidator{}
var _ validator.String = &amp;validTemplateViewTypeValidator{}
var _ validator.String = &amp;validTemplateDeviceTypeValidator{}

type validFqddsValidator struct {
}

// Description returns a plain text description of the validator's behavior, suitable for a practitioner to understand its impact.
func (v validFqddsValidator) Description(ctx context.Context) string <span class="cov8" title="1">{
        return fmt.Sprintf("Allowed values are : %s", clients.ValidFQDDS)
}</span>

// MarkdownDescription returns a markdown formatted description of the validator's behavior, suitable for a practitioner to understand its impact.
func (v validFqddsValidator) MarkdownDescription(ctx context.Context) string <span class="cov0" title="0">{
        return v.Description(ctx)
}</span>

// Validate runs the main validation logic of the validator, reading configuration data out of `req` and updating `resp` with diagnostics.
func (v validFqddsValidator) ValidateString(ctx context.Context, req validator.StringRequest, resp *validator.StringResponse) <span class="cov8" title="1">{
        fqdds := req.ConfigValue
        if fqdds.IsUnknown() || fqdds.IsNull() </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">inputFqdds := fqdds.ValueString()
        multipleInputFqdds := strings.Split(inputFqdds, ",")
        multipleValidFqdds := strings.Split(clients.ValidFQDDS, ",")
        isValid := false

        for _, inpFqdds := range multipleInputFqdds </span><span class="cov8" title="1">{
                inputFqddsVal := strings.TrimSpace(inpFqdds)
                isValid = false
                for _, validFqdds := range multipleValidFqdds </span><span class="cov8" title="1">{
                        if strings.EqualFold(validFqdds, inputFqddsVal) </span><span class="cov8" title="1">{
                                isValid = true
                                break</span>
                        }
                }
                <span class="cov8" title="1">if !isValid </span><span class="cov8" title="1">{
                        resp.Diagnostics.AddAttributeError(
                                req.Path,
                                clients.ErrInvalidFqdds,
                                v.Description(ctx),
                        )
                        break</span>
                }
        }

}

type validTemplateViewTypeValidator struct {
}

// Description returns a plain text description of the validator's behavior, suitable for a practitioner to understand its impact.
func (v validTemplateViewTypeValidator) Description(ctx context.Context) string <span class="cov8" title="1">{
        return fmt.Sprintf("Allowed values are  :  %s ", clients.ValidTemplateViewTypes)
}</span>

// MarkdownDescription returns a markdown formatted description of the validator's behavior, suitable for a practitioner to understand its impact.
func (v validTemplateViewTypeValidator) MarkdownDescription(ctx context.Context) string <span class="cov0" title="0">{
        return v.Description(ctx)
}</span>

// Validate runs the main validation logic of the validator, reading configuration data out of `req` and updating `resp` with diagnostics.
func (v validTemplateViewTypeValidator) ValidateString(ctx context.Context, req validator.StringRequest, resp *validator.StringResponse) <span class="cov8" title="1">{
        templateViewType := req.ConfigValue
        if templateViewType.IsUnknown() || templateViewType.IsNull() </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">validTemplateViewTypes := strings.Split(clients.ValidTemplateViewTypes, ",")
        for _, validTemplateViewType := range validTemplateViewTypes </span><span class="cov8" title="1">{
                if strings.EqualFold(strings.TrimSpace(templateViewType.ValueString()), validTemplateViewType) </span><span class="cov8" title="1">{
                        return
                }</span>
        }
        <span class="cov8" title="1">resp.Diagnostics.AddAttributeError(
                req.Path,
                clients.ErrInvalidTemplateViewType,
                v.Description(ctx),
        )</span>
}

type validTemplateDeviceTypeValidator struct {
}

// Description returns a plain text description of the validator's behavior, suitable for a practitioner to understand its impact.
func (v validTemplateDeviceTypeValidator) Description(ctx context.Context) string <span class="cov8" title="1">{
        return fmt.Sprintf("Allowed values are  :  %s ", clients.ValidTemplateDeviceTypes)
}</span>

// MarkdownDescription returns a markdown formatted description of the validator's behavior, suitable for a practitioner to understand its impact.
func (v validTemplateDeviceTypeValidator) MarkdownDescription(ctx context.Context) string <span class="cov0" title="0">{
        return v.Description(ctx)
}</span>

// Validate runs the main validation logic of the validator, reading configuration data out of `req` and updating `resp` with diagnostics.
func (v validTemplateDeviceTypeValidator) ValidateString(ctx context.Context, req validator.StringRequest, resp *validator.StringResponse) <span class="cov8" title="1">{
        templateDeviceType := req.ConfigValue
        if templateDeviceType.IsUnknown() || templateDeviceType.IsNull() </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov0" title="0">validTemplateDeviceTypes := strings.Split(clients.ValidTemplateDeviceTypes, ",")
        for _, validTemplateDeviceType := range validTemplateDeviceTypes </span><span class="cov0" title="0">{
                if strings.EqualFold(strings.TrimSpace(templateDeviceType.ValueString()), validTemplateDeviceType) </span><span class="cov0" title="0">{
                        return
                }</span>
        }
        <span class="cov0" title="0">resp.Diagnostics.AddAttributeError(
                req.Path,
                clients.ErrInvalidTemplateViewType,
                v.Description(ctx),
        )</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package ome

import (
        "context"
        "fmt"
        "terraform-provider-ome/clients"

        "github.com/hashicorp/terraform-plugin-framework/attr"
        "github.com/hashicorp/terraform-plugin-framework/schema/validator"
)

// To be removed in the upcoming release and use framework

var _ validator.Set = sizeAtLeastValidator{}

// sizeAtLeastValidator validates that list contains at least min elements.
type sizeAtLeastValidator struct {
        min int
}

// Description describes the validation in plain text formatting.
func (v sizeAtLeastValidator) Description(_ context.Context) string <span class="cov8" title="1">{
        return fmt.Sprintf(clients.ErrBaseLineTargetsSize, v.min)
}</span>

// MarkdownDescription describes the validation in Markdown formatting.
func (v sizeAtLeastValidator) MarkdownDescription(ctx context.Context) string <span class="cov0" title="0">{
        return v.Description(ctx)
}</span>

// Validate performs the validation.
func (v sizeAtLeastValidator) ValidateSet(ctx context.Context, req validator.SetRequest, resp *validator.SetResponse) <span class="cov8" title="1">{
        elems, ok := validateList(ctx, req, resp)
        if !ok </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">if len(elems) &lt; v.min </span><span class="cov8" title="1">{
                resp.Diagnostics.AddAttributeError(
                        req.Path,
                        v.Description(ctx),
                        fmt.Sprintf("current size : %d", len(elems)),
                )
        }</span>

}

func validateList(ctx context.Context, request validator.SetRequest, response *validator.SetResponse) ([]attr.Value, bool) <span class="cov8" title="1">{
        l := request.ConfigValue
        if l.IsUnknown() || l.IsNull() </span><span class="cov0" title="0">{
                return nil, false
        }</span>
        <span class="cov8" title="1">return l.Elements(), true</span>
}

// SizeAtLeast returns an AttributeValidator which ensures that any configured
// attribute value:
//
//   - Is a List.
//   - Contains at least min elements.
//
// Null (unconfigured) and unknown (known after apply) values are skipped.
func SizeAtLeast(min int) validator.Set <span class="cov0" title="0">{
        return sizeAtLeastValidator{
                min: min,
        }
}</span>

var _ validator.String = complianceStateValidator{}

// sizeAtLeastValidator validates that list contains at least min elements.
type complianceStateValidator struct {
}

// Description describes the validation in plain text formatting.
func (v complianceStateValidator) Description(_ context.Context) string <span class="cov8" title="1">{
        return fmt.Sprintf(clients.ErrBaseLineComplianceStatus, clients.ValidComplainceStatus)
}</span>

// MarkdownDescription describes the validation in Markdown formatting.
func (v complianceStateValidator) MarkdownDescription(ctx context.Context) string <span class="cov0" title="0">{
        return v.Description(ctx)
}</span>

// Validate performs the validation.
func (v complianceStateValidator) ValidateString(ctx context.Context, req validator.StringRequest, resp *validator.StringResponse) <span class="cov8" title="1">{
        input := req.ConfigValue
        if input.IsUnknown() || input.IsNull() </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">if !(input.ValueString() == clients.ValidComplainceStatus) </span><span class="cov8" title="1">{
                resp.Diagnostics.AddAttributeError(
                        req.Path,
                        v.Description(ctx),
                        fmt.Sprintf("current value : %s", input.ValueString()),
                )
        }</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
